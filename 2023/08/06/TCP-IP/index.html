

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#33cc66">
  <meta name="author" content="夏白">
  <meta name="keywords" content="">
  
    <meta name="description" content="第一章 网络基础知识本章总结了深入理解TCP&#x2F;IP所必备的基础知识，其中包括计算机与网络发展的历史及其标准化过程、OSI参考模型、网络概念的本质、网络构建的设备等。  1.5.4 OSI参考模型中各个分层的作用 1.应用层为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。 2.表示层将应用处理的信息转换为适合网络传输的格式，或将来自下一">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP&#x2F;IP">
<meta property="og:url" content="http://example.com/2023/08/06/TCP-IP/index.html">
<meta property="og:site_name" content="夏白の博客">
<meta property="og:description" content="第一章 网络基础知识本章总结了深入理解TCP&#x2F;IP所必备的基础知识，其中包括计算机与网络发展的历史及其标准化过程、OSI参考模型、网络概念的本质、网络构建的设备等。  1.5.4 OSI参考模型中各个分层的作用 1.应用层为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。 2.表示层将应用处理的信息转换为适合网络传输的格式，或将来自下一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230807235712949.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230807235618567.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230807235852276.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808000052023.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808000154353.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808000238716.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808000516173.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808000556301.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808000732196.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808000802091.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808000849069.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001008103.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001036683.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001100267.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001119864.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001211886.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001228803.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001432188.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001455680.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001526057.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001554371.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001613791.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001718144.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808001929348.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002018577.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002046068.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002107278.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002233619.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002301653.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002319361.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002347436.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002407313.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002424633.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002514388.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002546561.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002606055.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002636940.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002705006.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002731671.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002753716.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808002927010.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003031201.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003102947.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003153180.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003248407.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003317024.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003345863.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003418280.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003519662.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003546757.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003621251.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003644788.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003734256.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003802599.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003848805.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003910363.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808003948986.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004123698.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004144763.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004305558.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004326486.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004401064.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004427406.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004435351.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004455854.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004503827.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004544709.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004554701.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004615529.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004643184.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004703600.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004747608.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004829540.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004854219.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808004952068.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005044243.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005058815.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005128459.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005243392.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005320190.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005408145.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005440704.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005515241.png">
<meta property="og:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230808005536195.png">
<meta property="article:published_time" content="2023-08-06T15:50:56.000Z">
<meta property="article:modified_time" content="2023-08-07T16:55:44.835Z">
<meta property="article:author" content="夏白">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/08/06/TCP-IP/Workspaces/hexo/source_posts/TCP-IP/image-20230807235712949.png">
  
  
  
  <title>TCP/IP - 夏白の博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>夏白の博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="TCP/IP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-06 23:50" pubdate>
          2023年8月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          204 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">TCP/IP</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第一章-网络基础知识"><a href="#第一章-网络基础知识" class="headerlink" title="第一章 网络基础知识"></a>第一章 网络基础知识</h1><p>本章总结了深入理解TCP&#x2F;IP所必备的基础知识，其中包括计算机与网络发展的历史及其标准化过程、OSI参考模型、网络概念的本质、网络构建的设备等。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230807235712949.png" srcset="/img/loading.gif" lazyload alt="image-20230807235712949"></p>
<h2 id="1-5-4-OSI参考模型中各个分层的作用"><a href="#1-5-4-OSI参考模型中各个分层的作用" class="headerlink" title="1.5.4 OSI参考模型中各个分层的作用"></a>1.5.4 OSI参考模型中各个分层的作用</h2><p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230807235618567.png" srcset="/img/loading.gif" lazyload alt="image-20230807235618567"></p>
<h4 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1.应用层"></a>1.应用层</h4><p>为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。</p>
<h4 id="2-表示层"><a href="#2-表示层" class="headerlink" title="2.表示层"></a>2.表示层</h4><p>将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上一层能够处理的格式。因此它主要复制数据格式的转换。<br>具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对同一比特流解释的结果可能会不同。因此，使它们保持一致是这一层的主要作用。</p>
<h4 id="3-会话层"><a href="#3-会话层" class="headerlink" title="3.会话层"></a>3.会话层</h4><p>复制建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p>
<h4 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h4><p>起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理。</p>
<h4 id="5-网络层"><a href="#5-网络层" class="headerlink" title="5.网络层"></a>5.网络层</h4><p>将数据传输到目标地址。目标地址可以是多个网络网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。</p>
<h4 id="6-数据链路层"><a href="#6-数据链路层" class="headerlink" title="6.数据链路层"></a>6.数据链路层</h4><p>负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。<br>将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接受）。</p>
<h4 id="7-物理层"><a href="#7-物理层" class="headerlink" title="7.物理层"></a>7.物理层</h4><p>负责0、1比特流（0、1序列）与电压的高低、光的亮灭之间的互换。</p>
<h2 id="1-7-3-根据接收端类型分类"><a href="#1-7-3-根据接收端类型分类" class="headerlink" title="1.7.3 根据接收端类型分类"></a>1.7.3 根据接收端类型分类</h2><h4 id="1-单播（Unicast）"><a href="#1-单播（Unicast）" class="headerlink" title="1.单播（Unicast）"></a>1.单播（Unicast）</h4><p>1对1通信。早先的固定电话就是单播通信的一个典型例子。</p>
<h4 id="2-广播（Broadcast）"><a href="#2-广播（Broadcast）" class="headerlink" title="2.广播（Broadcast）"></a>2.广播（Broadcast）</h4><p>指将消息从1台主机发送给与之相连的所有其他主机。广播通信的一个典型例子就是电视播放，它将电视信号一齐发送给非特定的多个接受对象。<br>进行广播通信的计算机有一个广播范围，只有在这个范围之内的计算机才能接受到对应的广播消息。这个范围叫做广播域。</p>
<h4 id="3-多播（Multicast）"><a href="#3-多播（Multicast）" class="headerlink" title="3.多播（Multicast）"></a>3.多播（Multicast）</h4><p>多播与广播类似，也是将消息发送给多个接受主机。不同之处在于多播要限定某一组主机作为接受端。最典型的例子就是电视会议。</p>
<h4 id="4-任播（Anycast）"><a href="#4-任播（Anycast）" class="headerlink" title="4.任播（Anycast）"></a>4.任播（Anycast）</h4><p>任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。通常，所选中的那台特定主机将返回一个单播信号，随后发送端主机会只跟这台主机进行通信。在实际网络的应用有DNS根域名解析服务器。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230807235852276.png" srcset="/img/loading.gif" lazyload alt="image-20230807235852276"></p>
<h2 id="1-9-网络的构成要素"><a href="#1-9-网络的构成要素" class="headerlink" title="1.9 网络的构成要素"></a>1.9 网络的构成要素</h2><h4 id="1-网卡"><a href="#1-网卡" class="headerlink" title="1.网卡"></a>1.网卡</h4><p>中继器（物理层）<br>物理层面上延迟网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。中继器的两端连接的是相同的通信媒介，但有的中继器也可以完成不同媒介之间的转接工作。</p>
<h4 id="2-网桥-x2F-2层交换机（数据链路层）"><a href="#2-网桥-x2F-2层交换机（数据链路层）" class="headerlink" title="2.网桥&#x2F;2层交换机（数据链路层）"></a>2.网桥&#x2F;2层交换机（数据链路层）</h4><p>数据链路层面上连接两个网络的设备。它能够识别数据链路层中的数据帧，并将这些数据帧临时存储于内存，再生成信号作为一个全新的帧转发给相连的另一个网段。<br>数据位FCS用以校验数据是否正确送达目的地。</p>
<h4 id="3-路由器-x2F-3层交换机"><a href="#3-路由器-x2F-3层交换机" class="headerlink" title="3.路由器&#x2F;3层交换机"></a>3.路由器&#x2F;3层交换机</h4><p>网络层面上连接两个网络、并对分组报文进行转发的设备。网桥是根据物理地址（MAC）进行处理，而路由器则是根据IP地址进行处理的。<br>作用：<br>1.路由器可以连接不同的数据链路。<br>2.路由器还有分担网络负荷的作用。</p>
<h4 id="4-4-7层交换机"><a href="#4-4-7层交换机" class="headerlink" title="4.4~7层交换机"></a>4.4~7层交换机</h4><p>负责处理OSI某些模型中从传输层至应用层的数据。</p>
<h4 id="5-网关"><a href="#5-网关" class="headerlink" title="5.网关"></a>5.网关</h4><p>负责将从传输层到应用层的数据进行转换和转发的设备。它与4~7层交换机一样是处理传输层以上的数据。但是网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能直接进行通信的协议之间进行翻译，最终实现两者的通信。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808000052023.png" srcset="/img/loading.gif" lazyload alt="image-20230808000052023"></p>
<h1 id="第2章-TCP-x2F-IP基础知识"><a href="#第2章-TCP-x2F-IP基础知识" class="headerlink" title="第2章 TCP&#x2F;IP基础知识"></a>第2章 TCP&#x2F;IP基础知识</h1><p>TCP（Transmission Control Protocol）和IP（InternetProtocol）是互联网的众多通信协议中最为著名的。本章旨在介绍TCP&#x2F;IP的发展历程及其相关协议的概况。</p>
<h2 id="2-2-TCP-x2F-IP的标准化"><a href="#2-2-TCP-x2F-IP的标准化" class="headerlink" title="2.2 TCP&#x2F;IP的标准化"></a>2.2 TCP&#x2F;IP的标准化</h2><h3 id="2-2-1-TCP-x2F-IP的具体含义"><a href="#2-2-1-TCP-x2F-IP的具体含义" class="headerlink" title="2.2.1 TCP&#x2F;IP的具体含义"></a>2.2.1 TCP&#x2F;IP的具体含义</h3><p>它只是利用IP进行通信时所必须用到的协议群的统称。具体来讲，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP&#x2F;IP的协议。有时TCP&#x2F;IP也称网际协议族。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808000154353.png" srcset="/img/loading.gif" lazyload alt="image-20230808000154353"></p>
<h2 id="2-4-TCP-x2F-IP协议分层模型"><a href="#2-4-TCP-x2F-IP协议分层模型" class="headerlink" title="2.4 TCP&#x2F;IP协议分层模型"></a>2.4 TCP&#x2F;IP协议分层模型</h2><p>2.4.1 TCP&#x2F;IP与OSI参考模型</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808000238716.png" srcset="/img/loading.gif" lazyload alt="image-20230808000238716"></p>
<p>区别：OSI参考模型注重“通信协议必要的功能是什么”，而TCP&#x2F;IP则更强调“在计算机上实现协议应该开发哪种程序”。</p>
<h4 id="1-硬件（物理层）"><a href="#1-硬件（物理层）" class="headerlink" title="1.硬件（物理层）"></a>1.硬件（物理层）</h4><p>TCP&#x2F;IP的最底层是负责数据传输的硬件。</p>
<h4 id="2-网络接口层（数据链路层）"><a href="#2-网络接口层（数据链路层）" class="headerlink" title="2.网络接口层（数据链路层）"></a>2.网络接口层（数据链路层）</h4><p>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。</p>
<h4 id="3-互联网层（网络层）"><a href="#3-互联网层（网络层）" class="headerlink" title="3.互联网层（网络层）"></a>3.互联网层（网络层）</h4><p>互联网层使用IP协议，它相当于OSI模型中的第3层网络层。IP协议基于IP地址转发分包数据。所有连接互联网的主机和路由器都必须实现IP的功能，其他连接互联网的网络设备（如网桥、中继器或集线器）就没必要一定实现IP或TCP的功能。</p>
<h4 id="4-IP"><a href="#4-IP" class="headerlink" title="4.IP"></a>4.IP</h4><p>IP是跨域网络传送数据包，使整个互联网都能够收到数据的协议。<br>虽然IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此，属于非可靠性传输协议。</p>
<h4 id="5-ICMP"><a href="#5-ICMP" class="headerlink" title="5.ICMP"></a>5.ICMP</h4><p>IP数据包在发送途中一旦发生异常导致无法到达对端目的地址时，需要给发生端发送一个异常的通知。ICMP就是为这一功能而制定的。它有时也被用来诊断网络的健康状态。</p>
<h4 id="6-ARP"><a href="#6-ARP" class="headerlink" title="6.ARP"></a>6.ARP</h4><p>从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。</p>
<h4 id="7-传输层"><a href="#7-传输层" class="headerlink" title="7.传输层"></a>7.传输层</h4><p>传输层最主要的功能就是能够让应用程序之间实现通信。</p>
<h4 id="8-TCP"><a href="#8-TCP" class="headerlink" title="8.TCP"></a>8.TCP</h4><p>TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况，。此外，TCP还能够有效利用带宽，缓解网络拥堵。</p>
<h4 id="9-UDP"><a href="#9-UDP" class="headerlink" title="9.UDP"></a>9.UDP</h4><p>UDP是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据。<br>UDP常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。</p>
<h4 id="10-应用层（会话层以上的分层）"><a href="#10-应用层（会话层以上的分层）" class="headerlink" title="10.应用层（会话层以上的分层）"></a>10.应用层（会话层以上的分层）</h4><p>浏览器与服务端之间通信所用的协议是HTTP。所传输数据的主要格式是HTML。WWW中的HTTP属于OSI应用层的协议，而HTML属于表示层的协议。</p>
<h4 id="11-电子邮件（E-Mail）"><a href="#11-电子邮件（E-Mail）" class="headerlink" title="11.电子邮件（E-Mail）"></a>11.电子邮件（E-Mail）</h4><p>发送电子邮件时用到的协议叫做SMTP（Simple Mail Tranfer Protocol）。</p>
<h4 id="12-文件传输（FTP）"><a href="#12-文件传输（FTP）" class="headerlink" title="12.文件传输（FTP）"></a>12.文件传输（FTP）</h4><p>在FTP中进行文件传输时会建立两个TCP连接，分别是发出传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接。</p>
<h4 id="13-远程登录（TELNET-与-SSH）"><a href="#13-远程登录（TELNET-与-SSH）" class="headerlink" title="13.远程登录（TELNET 与 SSH）"></a>13.远程登录（TELNET 与 SSH）</h4><h4 id="14-网络管理（SNMP）"><a href="#14-网络管理（SNMP）" class="headerlink" title="14.网络管理（SNMP）"></a>14.网络管理（SNMP）</h4><p>在TCP&#x2F;IP中进行网络管理时，采用SNMP协议。使用SNMP管理的主机、网桥、路由器等称作SNMP代理（Agent），而进行管理的那一段叫做管理器。</p>
<h2 id="2-5-TCP-x2F-IP分层模型与通信示例"><a href="#2-5-TCP-x2F-IP分层模型与通信示例" class="headerlink" title="2.5 TCP&#x2F;IP分层模型与通信示例"></a>2.5 TCP&#x2F;IP分层模型与通信示例</h2><h3 id="2-5-2-发送数据包"><a href="#2-5-2-发送数据包" class="headerlink" title="2.5.2 发送数据包"></a>2.5.2 发送数据包</h3><h5 id="1-应用程序处理（应用层）—–编码处理与建立TCP连接。"><a href="#1-应用程序处理（应用层）—–编码处理与建立TCP连接。" class="headerlink" title="1.应用程序处理（应用层）—–编码处理与建立TCP连接。"></a>1.应用程序处理（应用层）—–编码处理与建立TCP连接。</h5><h5 id="2-TCP模块的处理（传输层）—–-TCP根据应用的指示，复制建立连接、发送数据以及断开连接。"><a href="#2-TCP模块的处理（传输层）—–-TCP根据应用的指示，复制建立连接、发送数据以及断开连接。" class="headerlink" title="2.TCP模块的处理（传输层）—– TCP根据应用的指示，复制建立连接、发送数据以及断开连接。"></a>2.TCP模块的处理（传输层）—– TCP根据应用的指示，复制建立连接、发送数据以及断开连接。</h5><h5 id="3-IP模块的处理（互联网层）-—–-IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据时TCP还是UDP的信息。"><a href="#3-IP模块的处理（互联网层）-—–-IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据时TCP还是UDP的信息。" class="headerlink" title="3.IP模块的处理（互联网层） —– IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据时TCP还是UDP的信息。"></a>3.IP模块的处理（互联网层） —– IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据时TCP还是UDP的信息。</h5><h5 id="4-网络接口（以太网驱动）的处理"><a href="#4-网络接口（以太网驱动）的处理" class="headerlink" title="4.网络接口（以太网驱动）的处理"></a>4.网络接口（以太网驱动）的处理</h5><p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808000516173.png" srcset="/img/loading.gif" lazyload alt="image-20230808000516173"></p>
<h3 id="2-5-3-经过数据链路层的包"><a href="#2-5-3-经过数据链路层的包" class="headerlink" title="2.5.3 经过数据链路层的包"></a>2.5.3 经过数据链路层的包</h3><p>包流动时，从前往后依次被附加了以太网包首部、IP包首部、TCP包首部（或UDP包首部）以及应用自己的包首部和数据。而包的最后则追加上了以太网包尾。</p>
<p>①每个包首部中至少都会包含两个信息：一个是发送端和接受端的地址，另一个是上一层的协议类型。</p>
<p>经过每个协议分层时，都必须有识别包发送端和接受端的信息。以太网会用MAC地址、IP会用IP地址，而TCP&#x2F;UDP则会用端口号作为识别两端主机的地址。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808000556301.png" srcset="/img/loading.gif" lazyload alt="image-20230808000556301"></p>
<p>②每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。例如以太网的包首部中的以太网类型，IP中的协议类型以及TCP&#x2F;UDP中两个端口的端口号等都起着识别协议类型的作用。</p>
<h3 id="2-5-4-数据包接收处理"><a href="#2-5-4-数据包接收处理" class="headerlink" title="2.5.4 数据包接收处理"></a>2.5.4 数据包接收处理</h3><h4 id="1-网络接口（以太网驱动）的处理"><a href="#1-网络接口（以太网驱动）的处理" class="headerlink" title="1.网络接口（以太网驱动）的处理"></a>1.网络接口（以太网驱动）的处理</h4><p>主机收到以太网包后，首先从以太网的包首部找到MAC地址判断是否为发给自己的包。如果不是发给自己的包则丢弃。而如果是发给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。如果这时不是IP而是其他诸如ARP的协议，就把数据传给ARP处理。总之，如果以太网包首部的类型域包含了一个无法识别的协议类型，则丢弃数据。</p>
<h4 id="2-IP模块的处理"><a href="#2-IP模块的处理" class="headerlink" title="2.IP模块的处理"></a>2.IP模块的处理</h4><p>IP模块收到IP包首部及后面的数据部分以后，也做类似的处理。如果判断得出包首部中的IP地址与自己的IP地址匹配，则可以接收数据并从中查找上一层的协议。即如果上一层是TCP则交给TCP处理，如果是UDP则交给UDP处理。对于有路由器的情况下，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送达的主机或路由器以后再转发数据。</p>
<h4 id="3-TCP模块的处理"><a href="#3-TCP模块的处理" class="headerlink" title="3.TCP模块的处理"></a>3.TCP模块的处理</h4><p>在TCP模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接受数据。最后检查端口号，确定具体的应用程序。数据接收完毕后，接收端会发生一个“确认回执”给发送端。如果这个回执未能到达发送端，则发送端会认为接收端没有接收到数据而一直反复发送。</p>
<h4 id="4-应用程序的处理"><a href="#4-应用程序的处理" class="headerlink" title="4.应用程序的处理"></a>4.应用程序的处理</h4><p>接收端应用程序接收数据。通过解析获取目的地址，如果没有该地址，会给发送端返回一个报错信息表明找不到目标。如果发送正常完成，就会给发送端发送一个“处理正常”的回执，反之发送“处理异常”。</p>
<h1 id="第3章-数据链路"><a href="#第3章-数据链路" class="headerlink" title="第3章 数据链路"></a>第3章 数据链路</h1><p>本章主要介绍计算机网络最基本的内容——数据链路层。如果没有数据链路层，基于TCP&#x2F;IP的通信也就无从谈起。因此，本章将着重介绍TCP&#x2F;IP的具体数据链路，如以太网、无线局域网、PPP等。</p>
<h2 id="3-2-数据链路相关技术"><a href="#3-2-数据链路相关技术" class="headerlink" title="3.2 数据链路相关技术"></a>3.2 数据链路相关技术</h2><h3 id="3-2-1-MAC地址"><a href="#3-2-1-MAC地址" class="headerlink" title="3.2.1 MAC地址"></a>3.2.1 MAC地址</h3><p>MAC地址用于识别数据链路中互连的节点（如图3.4）。以太网或FDDI中，根据IEEE02.3的规范使用MAC地址。其他诸如无线LAN、蓝牙等设备中也是用相同规格的MAC地址。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808000732196.png" srcset="/img/loading.gif" lazyload alt="image-20230808000732196"></p>
<p>MAC地址长48比特，如下图。<strong>任何一个网卡</strong>的MAC地址都是唯一的。但存在例外情况，实际上即使MAC地址相同，只要不是同属一个数据链路就不会出现问题。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808000802091.png" srcset="/img/loading.gif" lazyload alt="image-20230808000802091"></p>
<h3 id="3-2-2-共享介质型网络"><a href="#3-2-2-共享介质型网络" class="headerlink" title="3.2.2 共享介质型网络"></a>3.2.2 共享介质型网络</h3><p>从通信介质的使用方法上看，网络可分为共享介质型和非共享介质型。</p>
<p>共享介质型网络指多个设备共享一个通信介质的一种网络，如最早的以太网和FDDI，在这种方式下，设备之间使用同一个载波信道进行发送和接收。为此，基本上采用半双工通信方式，并有必要对介质进行访问控制。</p>
<p>共享介质型网络有两种介质访问控制方式：</p>
<h4 id="1-争用方式"><a href="#1-争用方式" class="headerlink" title="1.争用方式"></a>1.争用方式</h4><p>争用方式是指多去数据传输的权利，也叫CSMA（载波监听多路访问）。这种方式通常令网络中的各个站采用先到先得的方式占用信道发送数据，如果多个站同时发送帧，则会发送冲突现象，因此导致网络拥堵与性能下降。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808000849069.png" srcset="/img/loading.gif" lazyload alt="image-20230808000849069"></p>
<p>减弱冲突现象：<br>采用改良CSMA的另一种方式——CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）方式。CSMA&#x2F;CD要求每个站提前检查冲突，一旦发生冲突，则尽早释放信道。</p>
<p>CSMA&#x2F;CD工作原理（如图3.7）：<br>①如果载波信道上没有数据流动，则任何站都可以发送数据。<br>②检查是否会发生冲突。一旦发生冲突，放弃发送数据，同时立即释放载波信道。<br>③放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001008103.png" srcset="/img/loading.gif" lazyload alt="image-20230808001008103"></p>
<h4 id="2-令牌传递方式"><a href="#2-令牌传递方式" class="headerlink" title="2.令牌传递方式"></a>2.令牌传递方式</h4><p>令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文，是控制传输的一种方式。只有获取令牌的站才能发送数据。 但在网络不太拥堵的情况下数据链路的利用率也达不到100%。<br>这种方式有两个特点：<br>①不会有冲突<br>②每个站都有通过平等循环获得令牌的机会。因此，既是网络拥堵也不会导致性能下降。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001036683.png" srcset="/img/loading.gif" lazyload alt="image-20230808001036683"></p>
<h2 id="3-2-3-非共享介质型网络"><a href="#3-2-3-非共享介质型网络" class="headerlink" title="3.2.3 非共享介质型网络"></a>3.2.3 非共享介质型网络</h2><p>网络中的每个站直连交换机，由交换机转发帧。此方式下，发送端和接收端并不共享通信介质，因此很多情况下采用全双工通信方式。在一对一连接全双工的方式下不会发生冲突，因此不需要CSNA&#x2F;CD就可以实现更高效的通信。</p>
<p>该方式还可以根据交换机的高效特性构建虚拟局域网（VLAN）、进行流量控制等。缺点是一旦换机发生故障，与之相连的计算机之间都无法通信。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001100267.png" srcset="/img/loading.gif" lazyload alt="image-20230808001100267"></p>
<h3 id="3-2-4-根据MAC地址转发"><a href="#3-2-4-根据MAC地址转发" class="headerlink" title="3.2.4 根据MAC地址转发"></a>3.2.4 根据MAC地址转发</h3><p>以太网交换机就是持有多个端口的网桥。它们根据数据链路层中每个帧的目的MAC地址，决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表叫做转发表。转发表的内容是自动生成的，这一过程叫自学过程。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001119864.png" srcset="/img/loading.gif" lazyload alt="image-20230808001119864"></p>
<h3 id="3-2-5-环路检测技术"><a href="#3-2-5-环路检测技术" class="headerlink" title="3.2.5 环路检测技术"></a>3.2.5 环路检测技术</h3><p>解决网络中的环路问题有生成树和源路由两种方式。</p>
<h4 id="1-生成树方式"><a href="#1-生成树方式" class="headerlink" title="1.生成树方式"></a>1.生成树方式</h4><p>每个网桥必须在每1~10秒内相互交换BPDU包，从而判断哪些端口使用哪些不使用，以便消除环路。一旦发生故障，则自动切换通信线路，利用那些没有被使用的端口继续进行传输。</p>
<h4 id="2-源路由法"><a href="#2-源路由法" class="headerlink" title="2.源路由法"></a>2.源路由法</h4><p>该方法可以判断发送数据的源地址是哪个网桥实现传输的，并将帧写入RIF。网桥根据这个RIF信息发送帧给目标地址。因此网桥中即使出现环路，数据帧也不会被反复转发。</p>
<h3 id="3-2-6-VLAN"><a href="#3-2-6-VLAN" class="headerlink" title="3.2.6 VLAN"></a>3.2.6 VLAN</h3><p>相比一般的网桥&#x2F;2层交换机，VLAN可以过滤多余的包，提高网络的承载效率。</p>
<p>如图3.15所示，该交换机按照其端口区分了多个网段，从而区分了广播数据传播的范围，减少了网络负载并提高了网络的安全性。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001211886.png" srcset="/img/loading.gif" lazyload alt="image-20230808001211886"></p>
<p>TAG VLAN中对每个网段都用一个VLAN ID 的标签进行唯一表示。在交换机传输帧时，在以太网首部加入这个VID标签，根据这个值决定将数据帧发送给哪个网段（如图3.16）。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001228803.png" srcset="/img/loading.gif" lazyload alt="image-20230808001228803"></p>
<h2 id="3-3-以太网"><a href="#3-3-以太网" class="headerlink" title="3.3 以太网"></a>3.3 以太网</h2><h3 id="3-3-2-以太网的分类"><a href="#3-3-2-以太网的分类" class="headerlink" title="3.3.2 以太网的分类"></a>3.3.2 以太网的分类</h3><p>以太网中以时钟频率决定传输速度。<br>1K&#x3D;1000<br>1M&#x3D;1000K<br>1G&#x3D;1000M</p>
<h3 id="3-3-4-以太网帧格式"><a href="#3-3-4-以太网帧格式" class="headerlink" title="3.3.4 以太网帧格式"></a>3.3.4 以太网帧格式</h3><p>以太网帧前端有一个前导码，它由0、1数字交替组成，表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志。如图3.19所示。前导码末尾是一个叫做SFD的域，它的值时“11”。在这个域之后就是以太网帧的本体。前导码与SFD合起来占8个字节。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001432188.png" srcset="/img/loading.gif" lazyload alt="image-20230808001432188"></p>
<p>以太网帧本体的前端是以太网的首部，它总共占14个字节。分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001455680.png" srcset="/img/loading.gif" lazyload alt="image-20230808001455680"></p>
<p>紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是46~1500个字节。帧尾是一个叫做FCS（帧检验序列）的4个字节。它可以检查帧是否有所损坏，通过检查这个FCS字段的值可以将那些受到噪声干扰的错误帧丢弃。FCS中保存着整个帧除以生成多项式的余数。在接收端也用同样的方法计算，如果得到的FCS值相同，就说明帧没有差错。</p>
<p>VLAN中以太网帧的格式<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001526057.png" srcset="/img/loading.gif" lazyload alt="image-20230808001526057"></p>
<h2 id="3-5-PPP"><a href="#3-5-PPP" class="headerlink" title="3.5 PPP"></a>3.5 PPP</h2><h3 id="3-5-1-PPP定义"><a href="#3-5-1-PPP定义" class="headerlink" title="3.5.1 PPP定义"></a>3.5.1 PPP定义</h3><p>PPP是指点对点，即1对1连接计算机的协议。PPP相当于位于OSI参考模型第2层的数据链路层。PPP可以使用电话线或ISDN、专线、ATM线路。</p>
<h3 id="3-5-2-LCP与NCP"><a href="#3-5-2-LCP与NCP" class="headerlink" title="3.5.2 LCP与NCP"></a>3.5.2 LCP与NCP</h3><p>在PPP的主要功能中包含两个协议：一个是不依赖上层的LCP(Link Control Protocol)协议，另一个是依赖上层的NCP(Network Control Protocol)协议，如果上层为IP，也叫做IPCP(IP Control Protocol)。</p>
<p>LCP主要负责建立和断开连接、设置最大接受单元、设置验证协议（PAP或CHAP）以及设置是否进行通信质量的监控。</p>
<p>IPCP负责IP地址设置以及是否进行TCP&#x2F;IP首部压缩等设备。</p>
<h3 id="3-5-3-PPP的帧格式"><a href="#3-5-3-PPP的帧格式" class="headerlink" title="3.5.3 PPP的帧格式"></a>3.5.3 PPP的帧格式</h3><p>PPP的数据帧如图3.26所示。其中标志码用来区分每一个帧。在两个标志码中间不允许出现连续6个以上的“1”，因此在发送帧的时候，当连续出现5个“1”时后面必须插入一个0，接受端则当收到连续5个“1”且后面是0，则必须删除后面的0。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001554371.png" srcset="/img/loading.gif" lazyload alt="image-20230808001554371"></p>
<h3 id="3-5-4-PPPoE"><a href="#3-5-4-PPPoE" class="headerlink" title="3.5.4 PPPoE"></a>3.5.4 PPPoE</h3><p>有些互联网接入服务商在以太网上利用PPPoE提供PPP功能。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001613791.png" srcset="/img/loading.gif" lazyload alt="image-20230808001613791"></p>
<h3 id="3-6-其他数据链路"><a href="#3-6-其他数据链路" class="headerlink" title="3.6 其他数据链路"></a>3.6 其他数据链路</h3><h4 id="3-6-1-ATM"><a href="#3-6-1-ATM" class="headerlink" title="3.6.1 ATM"></a>3.6.1 ATM</h4><p>ATM(Asunchronous Transfer Mode)是以一个叫做信元（5字节首部加488字节数据）的单位进行传输的数据链路，由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>1.是一种面向连接的数据链路。允许同时与多个对端建立通信连接。<br>2.允许任何时候发送任何数据。因此，当大量计算机同时发送大量数据时容易引发网络拥堵甚至使网络进入收敛状态。</p>
<p><strong>收敛状态：</strong>指当网络非常拥堵时，路由器或交换机无法完成包的处理，从而丢弃这些包的一种状态。</p>
<h5 id="ATM与上层协议："><a href="#ATM与上层协议：" class="headerlink" title="ATM与上层协议："></a>ATM与上层协议：</h5><p>ATM的一个信元只能发送固定的48字节数据。这48个字节的数据部分若包含IP首部和TCP首部，则基本无法存放上层的数据。为此，一般不会单独使用ATM，而是使用上层的AAL。在上层为IP的情况下叫做AAL5。如图3.30所示，每个IP包被附加各层的协议首部以后，最多可以被分为192个信元发送出去。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001718144.png" srcset="/img/loading.gif" lazyload alt="image-20230808001718144"></p>
<p><strong>弊端</strong>：在ATM网中即使只是一个信元丢失，也要重新发送最多192个信元。<br>所以在构建ATM网络的时候。必须保证终端的带宽合计小于主干网的带宽，还要尽量保证信元不易丢失。</p>
<h2 id="3-7-专用网络"><a href="#3-7-专用网络" class="headerlink" title="3.7 专用网络"></a>3.7 专用网络</h2><h3 id="3-7-7-VPN"><a href="#3-7-7-VPN" class="headerlink" title="3.7.7 VPN"></a>3.7.7 VPN</h3><p>虚拟专用网络（VPN）用于连接距离较远的地域。这种服务包括IP-VPN和广域以太网。</p>
<h4 id="IP-VIN"><a href="#IP-VIN" class="headerlink" title="IP-VIN"></a>IP-VIN</h4><p>指在IP网络（互联网）上建立VPN。</p>
<p>网络服务商提供一种在IP网络上使用MPLS技术构建VPN的服务。其中MPLS在IP包中附加一个叫做标签的信息进行传输控制。每个用户的标签信息不同，因此在通过MPLS网时，可以轻松地判断出目标地址。</p>
<h4 id="广域以太网"><a href="#广域以太网" class="headerlink" title="广域以太网"></a>广域以太网</h4><p>服务提供商所提供的用于连接相距较远的地域一种服务。IP-VPN是在IP层面的连接，广域以太网则是在作为数据链路层的以太网上利用VLAN实现VPN的技术。</p>
<h1 id="第4章-IP协议"><a href="#第4章-IP协议" class="headerlink" title="第4章 IP协议"></a>第4章 IP协议</h1><h2 id="4-1-IP即网际协议"><a href="#4-1-IP即网际协议" class="headerlink" title="4.1 IP即网际协议"></a>4.1 IP即网际协议</h2><h3 id="4-1-1-IP相当于OSI参考模型的第3层"><a href="#4-1-1-IP相当于OSI参考模型的第3层" class="headerlink" title="4.1.1 IP相当于OSI参考模型的第3层"></a>4.1.1 IP相当于OSI参考模型的第3层</h3><p>IP（IPv4、IPv6）相当于OSI参考模型中的第3层——网络层。</p>
<p>网络层的主要作用是实现终端节点之间的通信。这种终端节点之间的通信也叫做“点对点（ebd-to-end）通信”。</p>
<p>网络层可以跨越不同的数据链路层，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
<p>主机与节点<br>准确的说，主机的定义是指“配置有IP地址，但是不进行路由控制的设备”。既配有IP地址又具有路由控制能力的设备叫做路由器。</p>
<h3 id="4-1-2-网络层与数据链路层的关系"><a href="#4-1-2-网络层与数据链路层的关系" class="headerlink" title="4.1.2 网络层与数据链路层的关系"></a>4.1.2 网络层与数据链路层的关系</h3><p>数据链路层提供直连两个设备之间的通信功能。与之相比，作为网络层的IP则负责在没有直连的两个网络之间进行通信传输。以旅行为例：</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808001929348.png" srcset="/img/loading.gif" lazyload alt="image-20230808001929348"></p>
<h2 id="4-2-IP基础知识"><a href="#4-2-IP基础知识" class="headerlink" title="4.2 IP基础知识"></a>4.2 IP基础知识</h2><p>本章我们来学习IP（Internet Protocol，网际协议）。IP作为整个TCP&#x2F;IP中至关重要的协议，主要负责将数据包发送给最终的目标计算机。因此，IP能够让世界上任何两台计算机之间进行通信。本章旨在详细介绍IP协议的主要功能及其规范。</p>
<p>IP大致分为三大作用模块：IP寻址、路由（最终节点为止的转发）以及IP分包与组包。</p>
<h3 id="4-2-1-IP地址属于网络层地址"><a href="#4-2-1-IP地址属于网络层地址" class="headerlink" title="4.2.1 IP地址属于网络层地址"></a>4.2.1 IP地址属于网络层地址</h3><p>在数据链路中MAC地址是用来标识同一个链路中的不同计算机的一种识别码，而网络层的IP也有这种地址信息，叫做IP地址。IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在TCP&#x2F;IP通信中所有主机或路由器必须设定自己的IP地址。</p>
<h3 id="4-2-2-路由控制"><a href="#4-2-2-路由控制" class="headerlink" title="4.2.2 路由控制"></a>4.2.2 路由控制</h3><p>路由控制（Routing）是指将分组数据发送到最终目标地址的功能。一个数据包之所以能够成功的到达最终的目标地址，全靠路由控制。</p>
<p>发送数据至最终目标地址<br>“跳”是指网络中的一个区间。IP路由也叫多跳路由，在每个区间内决定着包在下一跳被转发的路径。</p>
<p>多跳路由是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有通路全都指出来。如图4.6，以乘坐火车旅游为例：</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002018577.png" srcset="/img/loading.gif" lazyload alt="image-20230808002018577"></p>
<p><strong>路由控制表</strong><br>为了将数据包发送给目标主机，所有主机都维护着一张路由控制表（Routing Table）。该表记录IP数据在下一步应该发送给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002046068.png" srcset="/img/loading.gif" lazyload alt="image-20230808002046068"></p>
<h3 id="4-2-3-数据链路的抽象化"><a href="#4-2-3-数据链路的抽象化" class="headerlink" title="4.2.3 数据链路的抽象化"></a>4.2.3 数据链路的抽象化</h3><p>不同数据链路有个最大的区别，就是它们各自的最大传输单位（MTU）不同。如图4.9展示：</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002107278.png" srcset="/img/loading.gif" lazyload alt="image-20230808002107278"></p>
<p>MTU的值在以太网中是1500字节，在FDDI中是4352字节，而ATM则为9180字。IP的上一层可能会要求传送比这些MTU更多字节的数据，因此必须在线路上传送比包长还要小的MTU。</p>
<p>为了解决这个问题，IP进行分片处理，就是将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传给上一层。即从IP的上次层来看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需按照源地址发送的长度接收数据包。</p>
<h3 id="4-2-4-IP属于面向无连接型"><a href="#4-2-4-IP属于面向无连接型" class="headerlink" title="4.2.4 IP属于面向无连接型"></a>4.2.4 IP属于面向无连接型</h3><p>采用面向无连接的原因一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。每次通信之前都要事先建立连接，降低了处理速度。</p>
<p>为了提高可靠性，上一层的TCP采用面向有连接型。</p>
<h2 id="4-3-IP地址的基础知识"><a href="#4-3-IP地址的基础知识" class="headerlink" title="4.3 IP地址的基础知识"></a>4.3 IP地址的基础知识</h2><h3 id="4-3-1-IP地址的定义"><a href="#4-3-1-IP地址的定义" class="headerlink" title="4.3.1 IP地址的定义"></a>4.3.1 IP地址的定义</h3><p>IP地址（IPv4地址）由32位正整数来表示。IP地址在计算机内部以二进制方式被处理。将32位的IP地址以每8位为一组，分成4组，每组以“.”隔开，再将每组数转换成十进制数。如：<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002233619.png" srcset="/img/loading.gif" lazyload alt="image-20230808002233619"></p>
<h2 id="4-3-2-IP地址由网络和主机两部分标识组成"><a href="#4-3-2-IP地址由网络和主机两部分标识组成" class="headerlink" title="4.3.2 IP地址由网络和主机两部分标识组成"></a>4.3.2 IP地址由网络和主机两部分标识组成</h2><p>如图4.11，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。</p>
<p>IP地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的IP地址都不会相互重叠。即IP地址具有了唯一性。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002301653.png" srcset="/img/loading.gif" lazyload alt="image-20230808002301653"></p>
<p>如图4.12所示，IP包被转发到途中某个路由器时，正是利用目标IP地址的网络标识进行路由。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002319361.png" srcset="/img/loading.gif" lazyload alt="image-20230808002319361"></p>
<h3 id="4-3-3-IP地址的分类"><a href="#4-3-3-IP地址的分类" class="headerlink" title="4.3.3 IP地址的分类"></a>4.3.3 IP地址的分类</h3><p>IP地址分为四个等级，分别为A类、B类、C类、D类。它根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。</p>
<p>A类地址：<br>A类地址：0.0.0.0~127.0.0.0是A类地址的网络地址。A类地址的后24位相当于主机标识。</p>
<p>B类地址：<br>B类地址：128.0.0.1~191.255.0.0是B类地址的网络地址。B类地址的后16位相当于主机标识。</p>
<p>C类地址：<br>C类地址：192.168.0.0~239.255.255.0是C类地址的网络地址。C类地址的后8位相当于主机标识。</p>
<p>D类地址：<br>D类地址：224.0.0.0~239.255.255.255是D类地址的网络地址。D类地址没有主机标识，常被用于多播。</p>
<p>关于分配IP主机地址的注意事项<br>主机地址不可以全为0或全为1，因为只有0在表示对应的网络地址或IP地址不可获知的情况下才使用。全为1的主机地址通常作为广播地址。</p>
<h3 id="4-3-4-广播地址"><a href="#4-3-4-广播地址" class="headerlink" title="4.3.4 广播地址"></a>4.3.4 广播地址</h3><p>广播地址用于在同一个链路中相互连接的主机之间发送数据包。</p>
<p>两种广播： 本地广播和直接广播。<br>本地广播：在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0&#x2F;24的情况下，广播地址是192.168.0.255。因为这个广播地址会的IP包会被路由器屏蔽，所以不会到达192.168.0.0&#x2F;24以外的其他链路上。</p>
<p>直接广播：在不同网络之间的广播叫做直接广播。例如网络地址为192.168.0.0&#x2F;24的主机向192.168.1.255&#x2F;24的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.255&#x2F;24，从而使得所有192.168.1.1~192.168.1.254的主机都能接收到这个包。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002347436.png" srcset="/img/loading.gif" lazyload alt="image-20230808002347436"></p>
<h3 id="4-3-5-IP多播"><a href="#4-3-5-IP多播" class="headerlink" title="4.3.5 IP多播"></a>4.3.5 IP多播</h3><p>多播用于将包发送给特定组内的所有主机。由于其直接使用IP地址，因此也不存在可靠传输。多播既可以穿透路由器（广播不可以），又可以实现只给那些必要的组发送数据包。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002407313.png" srcset="/img/loading.gif" lazyload alt="image-20230808002407313"></p>
<p><strong>IP多播与地址</strong><br>多播使用D类地址。因此，如果从首位开始到第4位是“1110”，就可以认为是多播地址。而剩下的28位可以成为多播的组编号。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002424633.png" srcset="/img/loading.gif" lazyload alt="image-20230808002424633"></p>
<p>从224.0.0.0到239.255.255.255都是多播地址的可用范围。其中从224.0.0.0到224.0.0.255的范围不需要路由控制，在同一个链路内也能实现多播。而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。</p>
<p>此外，对于多播，所有的主机（路由器意外的主机和终端主机）必须属于224.0.0.1的组，所有的路由器必须属于224.0.0.2的组。</p>
<h3 id="4-3-6-子网掩码"><a href="#4-3-6-子网掩码" class="headerlink" title="4.3.6 子网掩码"></a>4.3.6 子网掩码</h3><p>子网与子网掩码<br>这种方式实际上就是将原来的A类、B类、C类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</p>
<p>自从引入子网以后，一个IP地址就有了两种识别码。一是IP地址本身，另一个是表示网络部的子网掩码。子网掩码对应IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分全部为“0”。子网掩码必须是IP地址的首位开始连续的“1”。</p>
<p>以172.20.100.52是网络地址的情况为例：</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002514388.png" srcset="/img/loading.gif" lazyload alt="image-20230808002514388"></p>
<h3 id="4-3-8-全局地址与私有地址"><a href="#4-3-8-全局地址与私有地址" class="headerlink" title="4.3.8 全局地址与私有地址"></a>4.3.8 全局地址与私有地址</h3><p>私有网络的IP地址范围如下：</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002546561.png" srcset="/img/loading.gif" lazyload alt="image-20230808002546561"></p>
<p>如果配有私有IP的地址主机联网时，则通过NAT进行通信。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002606055.png" srcset="/img/loading.gif" lazyload alt="image-20230808002606055"></p>
<h2 id="4-4-路由控制"><a href="#4-4-路由控制" class="headerlink" title="4.4 路由控制"></a>4.4 路由控制</h2><h3 id="4-4-1-IP地址与路由控制"><a href="#4-4-1-IP地址与路由控制" class="headerlink" title="4.4.1 IP地址与路由控制"></a>4.4.1 IP地址与路由控制</h3><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址，所谓最为吻合是指相同位数最多的意思。<br>主机路由<br>例如，192.168.153.15&#x2F;32就是一种主机路由。它的意思是整个IP地址的所有位都将参与路由。<br>环回地址<br>127.0.0.1&#x2F;localhost，使用这个IP或主机名时，数据包不会流向网络。</p>
<h3 id="4-4-2-路由控制表的聚合"><a href="#4-4-2-路由控制表的聚合" class="headerlink" title="4.4.2 路由控制表的聚合"></a>4.4.2 路由控制表的聚合</h3><p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002636940.png" srcset="/img/loading.gif" lazyload alt="image-20230808002636940"></p>
<h2 id="4-5-IP分割处理与再构成处理"><a href="#4-5-IP分割处理与再构成处理" class="headerlink" title="4.5 IP分割处理与再构成处理"></a>4.5 IP分割处理与再构成处理</h2><h3 id="4-5-2-IP报文的分片与重组"><a href="#4-5-2-IP报文的分片与重组" class="headerlink" title="4.5.2 IP报文的分片与重组"></a>4.5.2 IP报文的分片与重组</h3><p>图4.24展示了网络传输过程中进行分片处理的一个例子。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002705006.png" srcset="/img/loading.gif" lazyload alt="image-20230808002705006"></p>
<p>经过分片后的IP数据报在被重组的时候，只能有目标主机进行。路由器虽然做分片但不会进行重组。因为即使在途中某一处被重组，但如果下一站再经过其他路由是还会面临被分片的可能。这会给路由器带来多余的负担，也会降低网络传送效率。</p>
<h3 id="4-5-3-路径MTU发现"><a href="#4-5-3-路径MTU发现" class="headerlink" title="4.5.3 路径MTU发现"></a>4.5.3 路径MTU发现</h3><p>分片机制的不足：</p>
<p>路由器的处理负荷加重。<br>在分片处理中，一旦某个分片丢失，则会造成整个IP数据报作废。<br>如果使用更小的分片进行传输，会导致网路的利用率明显下降。<br>为了应对以上问题，产生了“路径MTU发现”（Path MTU Discovery）。所谓路径MTU发现是指从发送端到接收端主机之间不需要分片时最大MTU的大小。即路径中存在的所有数据链路中最小的MTU。</p>
<p>路径MTU发现工作原理：</p>
<p>首先在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1。根据这个标志位，途中的路由器即使遇到需要分片才能处理的大包，也不会去分片，而是将包丢弃。随后，通过一个ICMP的不可达消息将数据链路上MTU的值发送给主机。</p>
<p>下一次，从发送给同一个目标主机的IP报获得ICMP所通知的MTU值以后吗，将它设置为当前MTU。</p>
<p>路径MTU发现的机制（UDP）： IP层负责分片！</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002731671.png" srcset="/img/loading.gif" lazyload alt="image-20230808002731671"></p>
<p><strong>路径MTU发现的机制（TCP）：</strong> TCP负责分片，IP层不分片！！</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002753716.png" srcset="/img/loading.gif" lazyload alt="image-20230808002753716"></p>
<h2 id="4-6-IPv6"><a href="#4-6-IPv6" class="headerlink" title="4.6 IPv6"></a>4.6 IPv6</h2><p>IPv6的特点</p>
<h4 id="1-IP地址的扩大与路由控制表的聚合"><a href="#1-IP地址的扩大与路由控制表的聚合" class="headerlink" title="1.IP地址的扩大与路由控制表的聚合"></a>1.IP地址的扩大与路由控制表的聚合</h4><p>IP地址依然适应互联网分层构造。分配与其地址结构相适应的IP地址，尽可能避免路由表膨大。</p>
<h4 id="2-性能提升"><a href="#2-性能提升" class="headerlink" title="2.性能提升"></a>2.性能提升</h4><p>包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负荷。路由器不再做分片处理（通过路径MTU发现只由发送端主机进行分片处理）。</p>
<h4 id="3-支持即插即用功能"><a href="#3-支持即插即用功能" class="headerlink" title="3.支持即插即用功能"></a>3.支持即插即用功能</h4><p>即使没有DHCP服务器也可以实现自动分配IP地址。</p>
<h4 id="4-采用认证与加密功能"><a href="#4-采用认证与加密功能" class="headerlink" title="4.采用认证与加密功能"></a>4.采用认证与加密功能</h4><h4 id="5-多播、Mobile-IP成为扩展功能"><a href="#5-多播、Mobile-IP成为扩展功能" class="headerlink" title="5.多播、Mobile IP成为扩展功能"></a>5.多播、Mobile IP成为扩展功能</h4><h2 id="4-7-IPv4首部"><a href="#4-7-IPv4首部" class="headerlink" title="4.7 IPv4首部"></a>4.7 IPv4首部</h2><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>由4比特构成。</p>
<h4 id="首部长度"><a href="#首部长度" class="headerlink" title="首部长度"></a>首部长度</h4><p>由4比特构成，标识IP首部的大小，单位为4字节。</p>
<h4 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h4><h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><p>由16比特构成。</p>
<h4 id="标识（ID）"><a href="#标识（ID）" class="headerlink" title="标识（ID）"></a>标识（ID）</h4><p>由16比特构成，用于分片重组。同一个分片的标识值相同。通常，每发送一个IP包，它的值也逐渐增加。此外，即使ID相同，如果目标地址、源地址或协议不同的话也认为是不同的分片。</p>
<h4 id="标志（Flags）"><a href="#标志（Flags）" class="headerlink" title="标志（Flags）"></a>标志（Flags）</h4><p>由3比特构成。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808002927010.png" srcset="/img/loading.gif" lazyload alt="image-20230808002927010"></p>
<h5 id="片偏移（FO）"><a href="#片偏移（FO）" class="headerlink" title="片偏移（FO）"></a>片偏移（FO）</h5><p>由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。由于FO域占13位，因此最多可以表示8192（&#x3D;2^13）个相对位置。单位为8字节，因此最大可表示原始数据8 x 8192 &#x3D; 65536字节的位置。</p>
<h5 id="生存时间（TTL）"><a href="#生存时间（TTL）" class="headerlink" title="生存时间（TTL）"></a>生存时间（TTL）</h5><p>由8比特构成，实际中是指可以中转多少个路由器，每经过一个路由器TTL就减1，直到变成0则丢弃该包。</p>
<h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><p>由8比特构成，标识IPO首部的下一个首部隶属于哪个协议。</p>
<h5 id="首部校验和"><a href="#首部校验和" class="headerlink" title="首部校验和"></a>首部校验和</h5><p>由16比特（2个字节）构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。校验和的计算过程，首先要将该校验和的所有位置置0，然后以16比特为单位划分IP首部，并用1补救所有的16位字的和。最后将所得到的这个和的1补救赋给首部校验和字段。</p>
<h5 id="源地址"><a href="#源地址" class="headerlink" title="源地址"></a>源地址</h5><p>由32比特（4个字节）构成。</p>
<h5 id="目标地址"><a href="#目标地址" class="headerlink" title="目标地址"></a>目标地址</h5><p>由32比特（4个字节）构成。</p>
<h5 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h5><p>长度可变。</p>
<h5 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h5><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003031201.png" srcset="/img/loading.gif" lazyload alt="image-20230808003031201"></p>
<h2 id="4-8-IPv6首部格式"><a href="#4-8-IPv6首部格式" class="headerlink" title="4.8 IPv6首部格式"></a>4.8 IPv6首部格式</h2><p>IPv6中为了减少路由器的负担，省略了首部校验和字段。因此路由器不再需要计算校验和，从而也提高了包的转发效率。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003102947.png" srcset="/img/loading.gif" lazyload alt="image-20230808003102947"></p>
<h5 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h5><p>由4比特构成。</p>
<h5 id="通信量类"><a href="#通信量类" class="headerlink" title="通信量类"></a>通信量类</h5><p>由8比特构成。</p>
<h5 id="流标号"><a href="#流标号" class="headerlink" title="流标号"></a>流标号</h5><p>由20比特构成。</p>
<h5 id="有效载荷长度"><a href="#有效载荷长度" class="headerlink" title="有效载荷长度"></a>有效载荷长度</h5><p>有效载荷是指包的数据部分，不包含首部。</p>
<h5 id="下一个首部"><a href="#下一个首部" class="headerlink" title="下一个首部"></a>下一个首部</h5><h5 id="跳数限制（Hop-Limit）"><a href="#跳数限制（Hop-Limit）" class="headerlink" title="跳数限制（Hop Limit）"></a>跳数限制（Hop Limit）</h5><p>由8比特构成。</p>
<h5 id="源地址-1"><a href="#源地址-1" class="headerlink" title="源地址"></a>源地址</h5><h5 id="目标地址-1"><a href="#目标地址-1" class="headerlink" title="目标地址"></a>目标地址</h5><h5 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h5><p>扩展首部通常介于IPv6首部与TCP&#x2F;IP首部之间。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003153180.png" srcset="/img/loading.gif" lazyload alt="image-20230808003153180"></p>
<h1 id="第5章-IP协议相关技术"><a href="#第5章-IP协议相关技术" class="headerlink" title="第5章 IP协议相关技术"></a>第5章 IP协议相关技术</h1><p>IP（Internet Protocol）旨在让最终目标主机收到数据包，但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。此外，还会涉及IP必不可少的其他功能。</p>
<p>本章主要介绍作为IP的辅助和扩展规范的DNS、ARP、ICMP以及DHCP等协议。</p>
<h2 id="5-2-DNS"><a href="#5-2-DNS" class="headerlink" title="5.2 DNS"></a>5.2 DNS</h2><p>可以有效管理主机名和IP地址之间对应关系的系统，那就是DNS。在这个系统中主机的管理机构可以对数据进行变更和设定。也就是说，它可以维护一个用来表示组织内部主机名和IP地址之间对应关系的数据库。</p>
<h3 id="5-2-4-DNS查询"><a href="#5-2-4-DNS查询" class="headerlink" title="5.2.4 DNS查询"></a>5.2.4 DNS查询</h3><p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003248407.png" srcset="/img/loading.gif" lazyload alt="image-20230808003248407"></p>
<p>解析器（进行DNS查询的主机和软件叫做DNS解析器，如工作站或个人电脑）为了调查IP地址，向域名服务器进行查询处理。接收这个查询请求的域名服务器首先在自己的数据库进行查找。如果有该域名所对应的IP地址就返回。如果没有，则域名服务器再向上一层根域名服务器进行查询处理。</p>
<p>解析器和域名服务器将最新了解到的信息暂时保存在缓存中。这样，可以减少每次查询时的性能消耗。</p>
<h2 id="5-3-ARP"><a href="#5-3-ARP" class="headerlink" title="5.3 ARP"></a>5.3 ARP</h2><h3 id="5-3-1-ARP概要"><a href="#5-3-1-ARP概要" class="headerlink" title="5.3.1 ARP概要"></a>5.3.1 ARP概要</h3><p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址。不过ARP只适用于IPv4，IPv6可以用ICMPv6代替ARP发送邻居探索消息。</p>
<h3 id="5-3-2-ARP的工作原理"><a href="#5-3-2-ARP的工作原理" class="headerlink" title="5.3.2 ARP的工作原理"></a>5.3.2 ARP的工作原理</h3><p>ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003317024.png" srcset="/img/loading.gif" lazyload alt="image-20230808003317024"></p>
<p>如图5.6，主机A为了获得主机B的MAC地址，起初要通过广播发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机IP地址。也就是说，ARP请求包中已经包含了主机B的IP地址172.20.1.2。ARP的请求包会被这同一个链路上的所有主机或路由器接收，如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。</p>
<p>总之，从一个IP地址发送ARP请求以了解其MAC地址，目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过ARP从IP地址获得MAC地址，实现链路内的IP通信。</p>
<p>如果每发送一个IP数据报都有进行一次ARP请求以确定MAC地址，那将会造成不必要的网络流量，因此，通常的做法是把获取到的MAC地址缓存一段时间。 在发送主机端和接收主机端缓存MAC地址也是一种提高效率的方法。</p>
<h5 id="ARP包格式"><a href="#ARP包格式" class="headerlink" title="ARP包格式"></a>ARP包格式</h5><p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003345863.png" srcset="/img/loading.gif" lazyload alt="image-20230808003345863"></p>
<h3 id="5-3-3-IP地址与MAC地址缺一不可"><a href="#5-3-3-IP地址与MAC地址缺一不可" class="headerlink" title="5.3.3 IP地址与MAC地址缺一不可"></a>5.3.3 IP地址与MAC地址缺一不可</h3><h4 id="一、有了mac为什么还需要ip"><a href="#一、有了mac为什么还需要ip" class="headerlink" title="一、有了mac为什么还需要ip"></a>一、有了mac为什么还需要ip</h4><p>有唯一mac固然可以寻址，但是却不方便。mac地址是出厂自带的，至于后续设备到了哪里都是不可控的，所以mac没有规律可循。就好像快递员只用身份证号找人，由于人口是流动的，不一定就待在身份证号上的户籍地址，所以寻找难度过大。ip的优势正在于此。因为ip地址是可变的，且分为网络地址和主机地址，每一个接入网络的设备由DHCP服务器自动分配ip地址，同一个子网中的ip前几位是一样的，空间上靠近的设备ip前几位一样大大方便了寻址过程，再也不用满世界去找了，可以先找到子网，再在子网内找设备。</p>
<h4 id="二、有了ip为什么还需要mac"><a href="#二、有了ip为什么还需要mac" class="headerlink" title="二、有了ip为什么还需要mac"></a>二、有了ip为什么还需要mac</h4><p>（1）ip地址不是与生俱来，需要在接入网络后设备发送广播请求ip，DHCP服务器收到请求发送一个空闲的ip，设备收到回复发送租用请求，最后DHCP发送消息表示租用成功。在这个过程中由于设备还没有ip地址，所以需要mac地址来标识自己。假如同时有两个没有mac的设备接入网络，同时请求ip，那么DHCP服务器将不能区分是收到了两个请求还是同一个请求收到了两遍。</p>
<p>（2）mac先于ip存在，tcp&#x2F;ip协议诞生之前就有五花八门的网络，互相之间协议不互通，mac就是其中一个，tcp&#x2F;ip在更高层次上将他们连接起来，至于底层是什么交由各自管理。后来mac接近一统江湖，但是大局已定，而且这样做并没有明显的缺点，如果改动反而是困难重重（ipv6比v4那么大的优势缺还是难以取代），所以便沿用早期设计。</p>
<h3 id="5-3-4-RARP"><a href="#5-3-4-RARP" class="headerlink" title="5.3.4 RARP"></a>5.3.4 RARP</h3><p>RARP是将ARP反过来，从MAC地址定位IP地址的一种协议。如图5.9<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003418280.png" srcset="/img/loading.gif" lazyload alt="image-20230808003418280"></p>
<h3 id="5-3-5-代理ARP"><a href="#5-3-5-代理ARP" class="headerlink" title="5.3.5 代理ARP"></a>5.3.5 代理ARP</h3><p>通常ARP包会被路由器隔离，但是采用代理ARP（Proxy ARP）的路由器可以将ARP请求转发给邻近的网段。由此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p>
<h2 id="5-4-ICMP"><a href="#5-4-ICMP" class="headerlink" title="5.4 ICMP"></a>5.4 ICMP</h2><h3 id="5-4-1-辅助IP的ICMP"><a href="#5-4-1-辅助IP的ICMP" class="headerlink" title="5.4.1 辅助IP的ICMP"></a>5.4.1 辅助IP的ICMP</h3><p>构架IP网络时需要注意两点：确定网络是否正常运行以及遇到异常时进行问题诊断。ICMP（Internet Control Message Protocol）网际控制报文协议，正时提供这类功能的一种协议。</p>
<p><strong>主要功能：</strong><br>1.确认IP包是否发送成功送达目标地址<br>2。通知在发送过程当中IP包被废弃的具体原因<br>3.改善网络设置等。<br>4.有了这些功能，就可以获取网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p>
<p>如图5.10，主机A向主机B发送了数据包，由于某种原因，途中的路由器2未能发现主机B的存在，这时，路由器2就会向主机A发送一个ICMP包，说明发往主机B的包未能成功。</p>
<p>ICMP的这种通知消息会使用IP进行发送。因此，从路由器2返回的ICMP包会按照往常的路由控制先经过路由器1再转发给主机A。收到该ICMP包的主机则分解ICMP的首部和数据域以后得知具体发送问题的原因。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003519662.png" srcset="/img/loading.gif" lazyload alt="image-20230808003519662"></p>
<p>ICMP的消息大致可分为两类：一类是<strong>通知出错原因的错误消息</strong>，另一类是<strong>用于诊断的查询消息</strong>。</p>
<p>ICMP消息类型：<img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003546757.png" srcset="/img/loading.gif" lazyload alt="image-20230808003546757"></p>
<h3 id="5-4-2-主要的ICMP消息"><a href="#5-4-2-主要的ICMP消息" class="headerlink" title="5.4.2 主要的ICMP消息"></a>5.4.2 主要的ICMP消息</h3><p><strong>ICMP目标不可达消息（类型3）</strong><br>IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标地址不可达的ICMP消息，并在这个消息中显示不可达的具体原因。如表5.3所示：</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003621251.png" srcset="/img/loading.gif" lazyload alt="image-20230808003621251"></p>
<p><strong>ICMP重定向消息（类型5）</strong><br>如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的ICMP消息给发送端主机一个更合适的发送路由</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003644788.png" srcset="/img/loading.gif" lazyload alt="image-20230808003644788"></p>
<h5 id="ICMP超时消息（类型11）"><a href="#ICMP超时消息（类型11）" class="headerlink" title="ICMP超时消息（类型11）"></a>ICMP超时消息（类型11）</h5><p>IP包中有一个字段叫做TTL（Time to Live，生存周期），它的值随着每经过一次路由器就会减1，直到减到0时该IP包会被丢弃。此时，IP路由器将会发送一个ICMP超时的消息给发送端主机，并通知该包已被丢弃。</p>
<p>设置IP包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免IP包无休止地在网络上上被转发。此外，有时可以用TTL控制包的到达范围，例如设置一个较小的TTL值。</p>
<h5 id="ICMP回送消息（类型0、8）"><a href="#ICMP回送消息（类型0、8）" class="headerlink" title="ICMP回送消息（类型0、8）"></a>ICMP回送消息（类型0、8）</h5><p>用于进行通信的主机或路由器之间，判断所发送的数据包是否成功到达对端的一种消息。可以向对端主机发送回送请求的消息，也可以接收对端主机发回来的回送应答消息，网络上最常用的ping命令就是利用这个消息实现的。</p>
<h2 id="5-5-DHCP"><a href="#5-5-DHCP" class="headerlink" title="5.5 DHCP"></a>5.5 DHCP</h2><h3 id="5-5-1-DHCP实现即插即用"><a href="#5-5-1-DHCP实现即插即用" class="headerlink" title="5.5.1 DHCP实现即插即用"></a>5.5.1 DHCP实现即插即用</h3><p>为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP协议。DHCP在IPv4和IPv6都可以使用。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003734256.png" srcset="/img/loading.gif" lazyload alt="image-20230808003734256"></p>
<h3 id="5-5-2-DHCP的工作机制"><a href="#5-5-2-DHCP的工作机制" class="headerlink" title="5.5.2 DHCP的工作机制"></a>5.5.2 DHCP的工作机制</h3><p>使用DHCP之前，首先要架构一台DHCP服务器。然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将响应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p>
<p>关于从DHCP中获取IP地址的流程，以图5.17为例:</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003802599.png" srcset="/img/loading.gif" lazyload alt="image-20230808003802599"></p>
<p>为了检查所要分配的IP地址以及已经分配了的IP地址是否可用，DHCP服务器或客户端必须具备以下功能：</p>
<h5 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h5><p>在分配IP地址前发送ICMP回送请求包，确定没有返回应答。</p>
<h5 id="DHCP客户端"><a href="#DHCP客户端" class="headerlink" title="DHCP客户端"></a>DHCP客户端</h5><p>针对从DHCP那里获得的IP地址发送ARP请求包，确认没有返回应答。</p>
<h3 id="5-5-3-DHCP中继代理"><a href="#5-5-3-DHCP中继代理" class="headerlink" title="5.5.3 DHCP中继代理"></a>5.5.3 DHCP中继代理</h3><p>一个企业或学校等大规模组织机构的网络环境当中，会有多个以太网（无线LAN）网段。在这种情况下，若要针对每个网段都设置DHCP服务器将会是个庞大的工程。</p>
<p>因此，在这类网络环境中，往往需要将DHCP统一管理。具体方法可以使用DHCP中继代理来实现。</p>
<p>DHCP客户端会向DHCP中继代理发送DHCP请求包，而DHCP中继代理在收到这个广播包以后再以单播的形式发给DHCP服务器。服务器端收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端。由此，DHCP服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。</p>
<h2 id="5-6-NAT"><a href="#5-6-NAT" class="headerlink" title="5.6 NAT"></a>5.6 NAT</h2><h3 id="5-6-1-NAT定义"><a href="#5-6-1-NAT定义" class="headerlink" title="5.6.1 NAT定义"></a>5.6.1 NAT定义</h3><p>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接到互联网时转而使用全局IP地址的技术。除转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT。</p>
<h3 id="5-6-2-NAT的工作机制"><a href="#5-6-2-NAT的工作机制" class="headerlink" title="5.6.2 NAT的工作机制"></a>5.6.2 NAT的工作机制</h3><p>如图5.19所示</p>
<p>不包含端口号的转换方式（NAT）<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003848805.png" srcset="/img/loading.gif" lazyload alt="image-20230808003848805"></p>
<p>包含端口号的转换方式（NAPT）</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003910363.png" srcset="/img/loading.gif" lazyload alt="image-20230808003910363"></p>
<p>在使用TCP&#x2F;UDP的通信当中，只有目标地址、源地址、目标端口、源端口以及协议类型（TCP还是UDP）五项内容都一致时才被认为是同一个通信连接。此时所使用的正是NAPT。</p>
<p>如图5.20所示，生成一个NAPT路由器的转换表，就可以正确地转换地址跟端口的组合。这种转换表在NAT路由器上自动生成。例如，在TCP的情况下，建立TCP连接首次握手时的SYN包一经发出，就会生成这个表。而后又随着收到关闭连接时发出FIN包的确认应答从表中被删除。</p>
<h3 id="5-6-3-NAT-PT-NAPT-PT"><a href="#5-6-3-NAT-PT-NAPT-PT" class="headerlink" title="5.6.3 NAT-PT(NAPT-PT)"></a>5.6.3 NAT-PT(NAPT-PT)</h3><p>NAT-PT是将IPv6的首部转换为IPv4的首部的一种技术。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808003948986.png" srcset="/img/loading.gif" lazyload alt="image-20230808003948986"></p>
<h2 id="5-8-其他IP相关技术"><a href="#5-8-其他IP相关技术" class="headerlink" title="5.8 其他IP相关技术"></a>5.8 其他IP相关技术</h2><h3 id="5-8-2-IP任播"><a href="#5-8-2-IP任播" class="headerlink" title="5.8.2 IP任播"></a>5.8.2 IP任播</h3><p>IP任播是指为那些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法。主要用于110报警和119。</p>
<h3 id="5-8-3-通信质量控制"><a href="#5-8-3-通信质量控制" class="headerlink" title="5.8.3 通信质量控制"></a>5.8.3 通信质量控制</h3><p><strong>通信质量的定义</strong><br>通信线路上的拥塞叫做收敛。当网络发生故障时，路由器和集线器（交换集线器）的队列溢出，会出现大量的丢包现象，从而极端影响通信性能。</p>
<p>控制通信质量的机制</p>
<p><strong>1. IntServ</strong><br>IntServ是针对特定应用之间的通信进行质量控制的一种机制。这里的“特定的应用”是指源IP地址、目标IP地址、源端口、目标端口、以及协议号五项内容完全一致。</p>
<p>IntServ所涉及的通信并非一直进行，只是在必要的时候进行。一次IntServ也只有在必要的时候才要求在路由器上进行设置，这也叫“流量设置”，实现这种流量控制的协议正是RSVP。</p>
<p>RSVP中在接收端针对发送端传送控制包，并在它们之间所有的路由器上进行有质量控制的设定。</p>
<p><strong>2.DiffServ</strong></p>
<p>IntServ针对应用的连接进行详细的通信质量控制。相比之下，DiffServ则针对特定的网络进行较粗粒度的通信质量控制。</p>
<p>进行DiffServ质量控制的网络叫做DiffServ域。在该域中的路由器会对所有进入该域IP包首部的DSCP字段进行替换。对于期望被优化处理的包设置一个优先值。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004123698.png" srcset="/img/loading.gif" lazyload alt="image-20230808004123698"></p>
<h3 id="5-8-4-显示拥塞通知"><a href="#5-8-4-显示拥塞通知" class="headerlink" title="5.8.4 显示拥塞通知"></a>5.8.4 显示拥塞通知</h3><p>当发生网络拥塞时，发生主机应该减少数据包的发送量。作为IP上层协议，TCP虽然也能控制网络拥塞，不过它是通过数据包的实际损坏情况来判断是否发生拥塞。然而这种方法并不能在数据包损坏之前减少数据包的发送量。</p>
<p>为了解决这个问题，人们在IP层新增了一个使用显示拥塞通知的机制，即ECN。</p>
<p>ECN的机制概况起来就是在发送包的IP首部中记录路由器是否遇到拥塞，并在返回包的TCP首部中通知是否发生拥塞。拥塞检查在网络层进行，而拥塞通知则在传输层进行，这两层的互相协助实现了拥塞通知的功能。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004144763.png" srcset="/img/loading.gif" lazyload alt="image-20230808004144763"></p>
<h1 id="第6章-TCP与UDP"><a href="#第6章-TCP与UDP" class="headerlink" title="第6章 TCP与UDP"></a>第6章 TCP与UDP</h1><p>本章旨在介绍传输层的两个主要协议TCP（Transmission ControlProtocol）与UDP（User Datagram Protocol）。</p>
<h2 id="6-1-传输层的作用"><a href="#6-1-传输层的作用" class="headerlink" title="6.1 传输层的作用"></a>6.1 传输层的作用</h2><h3 id="6-1-3-两种传输层协议-TCP和UDP"><a href="#6-1-3-两种传输层协议-TCP和UDP" class="headerlink" title="6.1.3 两种传输层协议 TCP和UDP"></a>6.1.3 两种传输层协议 TCP和UDP</h3><p>TCP</p>
<p>TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。</p>
<p>TCP为提供可靠性传输、实行“顺序控制”或“重发控制”机制。此外还具有“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004305558.png" srcset="/img/loading.gif" lazyload alt="image-20230808004305558"></p>
<p><strong>UDP</strong></p>
<p>UDP是不具备可靠性的数据报协议。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。<img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004326486.png" srcset="/img/loading.gif" lazyload alt="image-20230808004326486"></p>
<h3 id="6-1-4-TCP与UDP区分"><a href="#6-1-4-TCP与UDP区分" class="headerlink" title="6.1.4 TCP与UDP区分"></a>6.1.4 TCP与UDP区分</h3><p>UDP主要用于对高速传输和实时性有较高要求的通信或广播通信。以IP电话通信为例，如果使用TCP，数据在传送过程中如果丢失被重发，这样无法流畅地传输通话人的声音，会导致无法正常交流。而采用UDP，它不会进行重发处理。即使有部分数据丢失，也只是影响一小部分的通话。此外，在多播和广播通信中也使用UDP。RIP、DHCP等基于广播的协议也要依赖于UDP。</p>
<p>Socket套接字</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004401064.png" srcset="/img/loading.gif" lazyload alt="image-20230808004401064"></p>
<h2 id="6-2-端口号"><a href="#6-2-端口号" class="headerlink" title="6.2 端口号"></a>6.2 端口号</h2><p>TCP：<img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004427406.png" srcset="/img/loading.gif" lazyload alt="image-20230808004427406"></p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004435351.png" srcset="/img/loading.gif" lazyload alt="image-20230808004435351"></p>
<p>UDP：<img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004455854.png" srcset="/img/loading.gif" lazyload alt="image-20230808004455854"></p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004503827.png" srcset="/img/loading.gif" lazyload alt="image-20230808004503827"></p>
<h2 id="6-3-UDP"><a href="#6-3-UDP" class="headerlink" title="6.3 UDP"></a>6.3 UDP</h2><p>UDP是User Datagram Protocol的缩写。</p>
<p>UDP不提供复杂的控制协议，利用IP提供面向无连接的通信服务。</p>
<p>即使是出现网络拥塞的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。传输途中如果出现丢包，UDP也不负责重发。当出现包顺序乱掉的时候也没有纠正的功能。</p>
<p>由于UDP面向无连接，它可以随时发送数据。再加上UDP本身的处理既简单又高效，因此经常用于以下几个方面：</p>
<p>包总量较少的通信（DNS、SNMP等）<br>视频、音频等多媒体通信（即时通信）<br>现定于LAN等特定网络中的应用通信<br>广播通信（广播、多播）</p>
<h2 id="6-4-TCP"><a href="#6-4-TCP" class="headerlink" title="6.4 TCP"></a>6.4 TCP</h2><p>TCP与UDP的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。TCP作为一种面向连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>
<h3 id="6-4-1-TCP的特点及其目的"><a href="#6-4-1-TCP的特点及其目的" class="headerlink" title="6.4.1 TCP的特点及其目的"></a>6.4.1 TCP的特点及其目的</h3><p>TCP通过检验和、序列化、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<h3 id="6-4-2-通过序列号与确认应答提高可靠性"><a href="#6-4-2-通过序列号与确认应答提高可靠性" class="headerlink" title="6.4.2 通过序列号与确认应答提高可靠性"></a>6.4.2 通过序列号与确认应答提高可靠性</h3><p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个亿收到消息的通知。这个消息叫做确认应答（ACK）。</p>
<p>如图6.8与6.9所示<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004544709.png" srcset="/img/loading.gif" lazyload alt="image-20230808004544709"></p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004554701.png" srcset="/img/loading.gif" lazyload alt="image-20230808004554701"></p>
<p>这些确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现。序列号是按顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。就这样，通过序列号和确认应答号，TCP可以实现可靠传输。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004615529.png" srcset="/img/loading.gif" lazyload alt="image-20230808004615529"></p>
<h3 id="6-4-4-连接管理"><a href="#6-4-4-连接管理" class="headerlink" title="6.4.4 连接管理"></a>6.4.4 连接管理</h3><p>TCP在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答。如果对端发来确认应答，则认为可以进行数据通信。此外，在通信结束时会进行断开连接的处理（FIN包）。</p>
<p>可以使用TCP首部用于控制的字段来管理TCP连接。一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成。</p>
<p><strong>三次握手四次挥手：</strong></p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004643184.png" srcset="/img/loading.gif" lazyload alt="image-20230808004643184"></p>
<h3 id="6-4-5-TCP是以段为单位发送数据"><a href="#6-4-5-TCP是以段为单位发送数据" class="headerlink" title="6.4.5 TCP是以段为单位发送数据"></a>6.4.5 TCP是以段为单位发送数据</h3><p>在建立TCP连接时，也可以确定发送数据包的单位，称为“最大消息长度”（MSS:Maximun Segment Size）。最理想的情况是：最大消息长度正好是IP中不会被分片处理的最大数据长度。</p>
<p>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。</p>
<p>MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小，然后在两者之间选择一个较小的值。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004703600.png" srcset="/img/loading.gif" lazyload alt="image-20230808004703600"></p>
<h3 id="6-4-6-利用窗口控制提高速度"><a href="#6-4-6-利用窗口控制提高速度" class="headerlink" title="6.4.6 利用窗口控制提高速度"></a>6.4.6 利用窗口控制提高速度</h3><p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。图6.15中，窗口大小为4个段。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004747608.png" srcset="/img/loading.gif" lazyload alt="image-20230808004747608"></p>
<p><strong>滑动窗口方式：</strong></p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004829540.png" srcset="/img/loading.gif" lazyload alt="image-20230808004829540"></p>
<h3 id="6-4-7-窗口控制和重发控制"><a href="#6-4-7-窗口控制和重发控制" class="headerlink" title="6.4.7 窗口控制和重发控制"></a>6.4.7 窗口控制和重发控制</h3><p>在使用窗口控制中，如果出现段丢失该怎么办？</p>
<p>首先，我们先考虑确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的。然而，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而使用了窗口控制，就如图6.17所示，某些确认应答即便丢失也无需重发。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004854219.png" srcset="/img/loading.gif" lazyload alt="image-20230808004854219"></p>
<p>其次，我们来考虑一下某个报文段丢失的情况。如图6.18所示，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答（不过即使接收端主机收到的包序号并不连续，也不会将数据丢弃而是暂时保存至缓冲区中）。<br>如图6.18所示。当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答 ，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作高速重发控制。<br><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808004952068.png" srcset="/img/loading.gif" lazyload alt="image-20230808004952068"></p>
<h3 id="6-4-8-流控制"><a href="#6-4-8-流控制" class="headerlink" title="6.4.8 流控制"></a>6.4.8 流控制</h3><p>发送端根据自己的实际情况发送数据。但是，接收端可能收到的是一个毫无关系的数据包又可能会在处理其他问题上花费一些时间。为了防止这种现象的发生，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口大小。</p>
<p>TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越高。</p>
<p>不过，接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的TCP流控制（流量控制）。</p>
<p>图6.19为根据窗口大小控制流量过程的示例。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005044243.png" srcset="/img/loading.gif" lazyload alt="image-20230808005044243">如图6.19所示，当接收端收到从3001号开始的数据段后其缓冲区即满，不得不暂时停止接收数据。之后，在收到发送窗口更新通知后通信才得以继续进行。如果这个窗口的更新通知在传送途中丢失，可能会导致无法继续通信。为避免此类问题的发生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。</p>
<h3 id="6-4-9-拥塞控制"><a href="#6-4-9-拥塞控制" class="headerlink" title="6.4.9 拥塞控制"></a>6.4.9 拥塞控制</h3><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。</p>
<p>TCP为了防止该问题的出现，在通信一开始时就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。<img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005058815.png" srcset="/img/loading.gif" lazyload alt="image-20230808005058815"></p>
<p>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念。于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS） 发送数据，之后每收到一次确认应答（ACK），拥塞窗口的值就加1。在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小那个值，发送比其还要小的数据量。</p>
<p>如果重发采用超时机制，那么拥塞窗口的初始值可以设置为1以后再进行慢启动修正。有了上述这些机制，就可以有效地减少通信开始时连续发包导致的网络拥堵，还可以避免网络拥塞情况的发生。</p>
<p>不过，随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生。为了防止这些，引入了慢启动阀值的概念。只要拥塞窗口的值超出这个阀值，在每收到一次确认应答时，只允许以下面这种比例放大拥塞窗口：</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005128459.png" srcset="/img/loading.gif" lazyload alt="image-20230808005118574"></p>
<p>拥塞窗口越大，确认应答的数目也会增加。不过随着每收到一个确认应答，其涨幅也会逐渐减少，甚至小过比一个数据段还要小的字节数。因此，拥塞窗口的大小会呈直线上升的趋势。</p>
<p>TCP的通信开始时，并没有设置相应的慢启动阀值 。而是在超时重发时，才会设置为当时拥塞窗口一半的大小。</p>
<p>由重复确认应答而触发的高速重发与超时重发机制的处理多少有些不同。因为前者要求至少3次的确认应答数据段到达对方主机后才会触发，相比后者网络的拥堵要轻一些。</p>
<p>而由重复确认应答进行高速重发控制时，慢启动阀值的大小被设置为当时窗口大小的一半（严格来说，是设置为“实际已发送但未收到确认应答的数据量”的一半）。然后将窗口的大小设置为该慢启动阀值+3个数据段的大小。</p>
<p>有了这样一种控制，TCP的拥塞窗口如图6.21所示发生变化。由于窗口的大小会直接影响数据被转发时的吞吐量，所以一般情况下，窗口越大，越会形成高吞吐量的通信。</p>
<h2 id="6-5-其他传输层协议"><a href="#6-5-其他传输层协议" class="headerlink" title="6.5 其他传输层协议"></a>6.5 其他传输层协议</h2><h3 id="6-5-1-UDP-Lite"><a href="#6-5-1-UDP-Lite" class="headerlink" title="6.5.1 UDP-Lite"></a>6.5.1 UDP-Lite</h3><p>UDP-Lite（Lightweight User Datagram Protocol，轻量级用户数据报协议）是扩展UDP机能的一种传输层协议。在基于UDP的通信当中如果校验和出现错误，所收到的包将被全部丢弃。然而，现实操作中，有些应用（例如那些使用H.263+，H.264，MPEG-4等图像与音频数据格式的应用。） 在面对这种情况时并不希望把已经收到的所有包丢弃。</p>
<p>UDP-Lite提供与UDP几乎相同的功能，不过计算校验和的范围可以由应用自行决定。这个范围可以是包加上伪首部的校验和计算，可以是首部与伪首部的校验和计算，也可以是首部、伪首部与数据从起始到中间某个位置的校验和计算 。有了这样的机制，就可以只针对不允许发生错误的部分进行校验和的检查。对于其他部分，即使发生了错误，也会被忽略不计。而这个包也不会被丢弃，而是直接传给应用继续处理。</p>
<h3 id="6-5-2-SCTP"><a href="#6-5-2-SCTP" class="headerlink" title="6.5.2 SCTP"></a>6.5.2 SCTP</h3><p>SCTP（Stream Control Transmission Protocol，流控制传输协议）与TCP一样，都是对一种提供数据到达与否相关可靠性检查的传输层协议。其主要特点如下：</p>
<h5 id="以消息为单位收发"><a href="#以消息为单位收发" class="headerlink" title="以消息为单位收发"></a>以消息为单位收发</h5><p>TCP中接收端并不知道发送端应用所决定的消息大小。在SCTP中却可以。</p>
<h5 id="支持多重宿主"><a href="#支持多重宿主" class="headerlink" title="支持多重宿主"></a>支持多重宿主</h5><p>在有多个NIC的主机中，即使其中能够使用的NIC发生变化，也仍然可以继续通信（这与TCP相比提高了故障应对能力） 。</p>
<h5 id="支持多数据流通信"><a href="#支持多数据流通信" class="headerlink" title="支持多数据流通信"></a>支持多数据流通信</h5><p>TCP中建立多个连接以后才能进行通信的效果，在SCTP中一个连接就可以。（吞吐量得到有效提升。）</p>
<h5 id="可以定义消息的生存期限"><a href="#可以定义消息的生存期限" class="headerlink" title="可以定义消息的生存期限"></a>可以定义消息的生存期限</h5><p>超过生存期限的消息，不会被重发。</p>
<p>SCTP主要用于进行通信的应用之间发送众多较小消息的情况。这些较小的应用消息被称作数据块（Chunk），多个数据块组成一个数据包。</p>
<p>此外，SCTP具有支持多重宿主以及设定多个IP地址的特点。多重宿主是指同一台主机具备多种网络的接口。例如，笔记本电脑既可以连接以太网又可以连接无线LAN。同时使用以太网和无线LAN时，各自的NIC会获取到不同的IP地址。进行TCP通信，如果开始时使用的是以太网，而后又切换为无线LAN，那么连接将会被断开。因为从SYN到FIN包必须使用同一个IP地址。</p>
<p>然而在SCTP的情况下，由于可以管理多个IP地址使其同时进行通信，因此即使出现通信过程当中以太网与无线LAN之间的切换，也能够保持通信不中断。所以SCTP可以为具备多个NIC的主机提供更可靠的传输（持有多个NIC的应用服务器中，即使某一个NIC发生故障，只要有一个能够正常工作的NIC就可以保持通信无阻） 。</p>
<h3 id="6-5-3-DCCP"><a href="#6-5-3-DCCP" class="headerlink" title="6.5.3 DCCP"></a>6.5.3 DCCP</h3><p>DCCP（Datagram Congestion Control Protocol，数据报拥塞控制协议）是一个辅助UDP的崭新的传输层协议。UDP没有拥塞控制机制。为此，当应用使用UDP发送大量数据包时极容易出现问题。于是便出现了DCCP这样的规范。</p>
<p>DCCP具有如下几个特点：</p>
<p>与UDP一样，不能提供发送数据的可靠性传输。<br>它面向连接，具备建立连接与断开连接的处理。在建立和断开连接上是具有可靠性。<br>能够根据网络拥堵情况进行拥塞控制。使用DCCP（RFC4340）应用可以根据自身特点选择两种方法进行拥塞控制。它们分别是“类似TCP（TCP-Like）拥塞控制”和“TCP友好升级控制”（TCP-Friendly Rate Control）。<br>为了进行拥塞控制，接收端收到包以后返回确认应答（ACK）。该确认应答将被用于重发与否的判断。</p>
<h2 id="6-6-UDP首部的格式"><a href="#6-6-UDP首部的格式" class="headerlink" title="6.6 UDP首部的格式"></a>6.6 UDP首部的格式</h2><p>图6.24展示了UDP首部的格式。除去数据的部分正是UDP的首部。UDP首部由源端口号，目标端口号，包长和校验和组成。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005243392.png" srcset="/img/loading.gif" lazyload alt="image-20230808005243392"></p>
<h5 id="源端口号（Source-Port）"><a href="#源端口号（Source-Port）" class="headerlink" title="源端口号（Source Port）"></a>源端口号（Source Port）</h5><p>表示发送端端口号，字段长16位。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候该字段的值设置为0。可用于不需要返回的通信中。</p>
<h5 id="目标端口号（Destination-Port）"><a href="#目标端口号（Destination-Port）" class="headerlink" title="目标端口号（Destination Port）"></a>目标端口号（Destination Port）</h5><p>表示接收端端口，字段长度16位。</p>
<h5 id="包长度（Length）"><a href="#包长度（Length）" class="headerlink" title="包长度（Length）"></a>包长度（Length）</h5><p>该字段保存了UDP首部的长度跟数据的长度之和 。单位为字节（8位字节）。</p>
<h5 id="校验和（Checksum）"><a href="#校验和（Checksum）" class="headerlink" title="校验和（Checksum）"></a>校验和（Checksum）</h5><p>校验和是为了提供可靠的UDP首部和数据而设计。</p>
<h2 id="6-7-TCP首部格式"><a href="#6-7-TCP首部格式" class="headerlink" title="6.7 TCP首部格式"></a>6.7 TCP首部格式</h2><p>图6.26展示了TCP首部的格式。TCP首部相比UDP首部要复杂得多。另外，TCP中没有表示包长度和数据长度的字段。可由IP层获知TCP的包长由TCP的包长可知数据的长度。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005320190.png" srcset="/img/loading.gif" lazyload alt="image-20230808005320190"></p>
<h5 id="源端口号（Source-Port）-1"><a href="#源端口号（Source-Port）-1" class="headerlink" title="源端口号（Source Port）"></a>源端口号（Source Port）</h5><p>表示发送端端口号，字段长16位。</p>
<h5 id="目标端口号（Destination-Port）-1"><a href="#目标端口号（Destination-Port）-1" class="headerlink" title="目标端口号（Destination Port）"></a>目标端口号（Destination Port）</h5><p>表示接收端端口号，字段长度16位。</p>
<h5 id="序列号（Sequence-Number）"><a href="#序列号（Sequence-Number）" class="headerlink" title="序列号（Sequence Number）"></a>序列号（Sequence Number）</h5><p>字段长32位。序列号（有时也叫序号）是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小。</p>
<p>序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</p>
<h5 id="确认应答号（Acknowledgement-Number）"><a href="#确认应答号（Acknowledgement-Number）" class="headerlink" title="确认应答号（Acknowledgement Number）"></a>确认应答号（Acknowledgement Number）</h5><p>确认应答号字段长度32位。是指下一次应该收到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。</p>
<h5 id="数据偏移（Data-Offset）"><a href="#数据偏移（Data-Offset）" class="headerlink" title="数据偏移（Data Offset）"></a>数据偏移（Data Offset）</h5><p>该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看作TCP首部的长度。该字段长4位，单位为4字节（即32位）。不包括选项字段的话，如图6.26所示TCP的首部为20字节长，因此数据偏移字段可以设置为5。反之，如果该字段的值为5，那说明从TCP包的最一开始到20字节为止都是TCP首部，余下的部分为TCP数据。</p>
<h5 id="保留（Reserved）"><a href="#保留（Reserved）" class="headerlink" title="保留（Reserved）"></a>保留（Reserved）</h5><p>该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃 。</p>
<h5 id="控制位（Control-Flag）"><a href="#控制位（Control-Flag）" class="headerlink" title="控制位（Control Flag）"></a>控制位（Control Flag）</h5><p>字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当它们对应位上的值为1时，具体含义如图6.27所示。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005408145.png" srcset="/img/loading.gif" lazyload alt="image-20230808005408145"></p>
<h5 id="WR（Congestion-Window-Reduced）"><a href="#WR（Congestion-Window-Reduced）" class="headerlink" title="WR（Congestion Window Reduced）"></a>WR（Congestion Window Reduced）</h5><p>CWR标志 与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</p>
<h5 id="ECE（ECN-Echo）"><a href="#ECE（ECN-Echo）" class="headerlink" title="ECE（ECN-Echo）"></a>ECE（ECN-Echo）</h5><p>ECE标志 表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。</p>
<h5 id="URG（Urgent-Flag）"><a href="#URG（Urgent-Flag）" class="headerlink" title="URG（Urgent Flag）"></a>URG（Urgent Flag）</h5><p>该位为1时，表示包中有需要紧急处理的数据。</p>
<h5 id="ACK（Acknowledgement-Flag）"><a href="#ACK（Acknowledgement-Flag）" class="headerlink" title="ACK（Acknowledgement Flag）"></a>ACK（Acknowledgement Flag）</h5><p>该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。</p>
<h5 id="PSH（Push-Flag）"><a href="#PSH（Push-Flag）" class="headerlink" title="PSH（Push Flag）"></a>PSH（Push Flag）</h5><p>该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</p>
<h5 id="RST（Reset-Flag）"><a href="#RST（Reset-Flag）" class="headerlink" title="RST（Reset Flag）"></a>RST（Reset Flag）</h5><p>该位为1时表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发来连接请求，也无法进行通信。此时就可以返回一个RST设置为1的包。</p>
<h5 id="SYN（Synchronize-Flag）"><a href="#SYN（Synchronize-Flag）" class="headerlink" title="SYN（Synchronize Flag）"></a>SYN（Synchronize Flag）</h5><p>用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定（Synchronize本身有同步的意思。也就意味着建立连接的双方，序列号和确认应答号要保持同步） 。</p>
<h5 id="FIN（Fin-Flag）"><a href="#FIN（Fin-Flag）" class="headerlink" title="FIN（Fin Flag）"></a>FIN（Fin Flag）</h5><p>该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位置为1的TCP段。每个主机又对对方的FIN包进行确认应答以后就可以断开连接。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。</p>
<h5 id="窗口大小（Window-Size）"><a href="#窗口大小（Window-Size）" class="headerlink" title="窗口大小（Window Size）"></a>窗口大小（Window Size）</h5><p>该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小（8位字节）。TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。</p>
<h5 id="校验和（Checksum）-1"><a href="#校验和（Checksum）-1" class="headerlink" title="校验和（Checksum）"></a>校验和（Checksum）</h5><p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005440704.png" srcset="/img/loading.gif" lazyload alt="image-20230808005440704"></p>
<p>TCP和UDP一样在计算校验和的时候使用TCP伪首部。这个伪首部如图6.28所示。为了让其全长为16位的整数倍，需要在数据部分的最后填充0。首先将TCP校验和字段设置为0。然后以16位为单位进行1的补码和计算，再将它们总和的1的补码和放入校验和字段。</p>
<p>接收端在收到TCP数据段以后，从IP首部获取IP地址信息构造TCP伪首部，再进行校验和计算。由于校验和字段里保存着除本字段以外其他部分的和的补码值，因此如果计算校验和字段在内的所有数据的16位和以后，得出的结果是“16位全部为1 ”说明所收到的数据是正确的。</p>
<h5 id="使用校验和的目的是什么？"><a href="#使用校验和的目的是什么？" class="headerlink" title="使用校验和的目的是什么？"></a>使用校验和的目的是什么？</h5><p>TCP或UDP如果能够提供校验和计算，也可以判断协议首部和数据是否被破坏。</p>
<h5 id="紧急指针（Urgent-Pointer）"><a href="#紧急指针（Urgent-Pointer）" class="headerlink" title="紧急指针（Urgent Pointer）"></a>紧急指针（Urgent Pointer）</h5><p>该字段长为16位。只有在URG控制位为1时有效。该字段的数值表示本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指针所指示的位置为止为紧急数据。因此也可以说紧急指针指出了紧急数据的末尾在报文段中的位置。</p>
<h5 id="选项（Options）"><a href="#选项（Options）" class="headerlink" title="选项（Options）"></a>选项（Options）</h5><p>选项字段用于提高TCP的传输性能。因为根据数据偏移（首部长度）进行控制，所以其长度最大为40字节。</p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005515241.png" srcset="/img/loading.gif" lazyload alt="image-20230808005515241"></p>
<p><strong>窗口大小与吞吐量</strong></p>
<p><img src="/2023/08/06/TCP-IP/Workspaces\hexo\source_posts\TCP-IP\image-20230808005536195.png" srcset="/img/loading.gif" lazyload alt="image-20230808005536195"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>TCP/IP</div>
      <div>http://example.com/2023/08/06/TCP-IP/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>夏白</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/06/%E5%B0%9A%E7%A1%85%E8%B0%B7Docker/" title="尚硅谷Docker">
                        <span class="hidden-mobile">尚硅谷Docker</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Study hard</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Day day up！</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
